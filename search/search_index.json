{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyMSM in a nutshell \u00a4 Hagai Rossman , Ayya Keshet , Malka Gorfine 2022 PyMSM is a Python package for fitting competing risks and multistate models, with a simple API which allows user-defined model, predictions at a single or population sample level, statistical summaries and figures. Features include: Fit a Competing risks Multistate model based on survival analysis (time-to-event) models. Deals with right censoring, competing events, recurrent events, left truncation, and time-dependent covariates. Run Monte-carlo simulations for paths emitted by the trained model and extract various summary statistics and plots. Load or configure a pre-defined model and run path simulations. Modularity and compatibility for different time-to-event models such as Survival Forests and other custom models. Installation \u00a4 pip install pymsm Requires Python >=3.8 Quick example \u00a4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Load data (See Rotterdam example for full details) from pymsm.datasets import prep_rotterdam dataset , states_labels = prep_rotterdam () # Define terminal states terminal_states = [ 3 ] #Init MultistateModel from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset , terminal_states ) # Fit model to data multi_state_model . fit () # Run Monte-Carlo simulation and sample paths mcs = multi_state_model . run_monte_carlo_simulation ( sample_covariates = dataset [ 0 ] . covariates . values , origin_state = 1 , current_time = 0 , max_transitions = 2 , n_random_samples = 10 , print_paths = True ) stateDiagram-v2 s1 : (1) Primary surgery s2 : (2) Disease recurrence s3 : (3) Death s1 --> s2: 1518 s1 --> s3: 195 s2 --> s3: 1077 Background and Motivation \u00a4 Multi-state data are common, and could be used to describe trajectories in diverse health applications; such as describing a patient's progression through disease stages or a patient\u2019s path through different hospitalization states. When faced with such data, a researcher or clinician might seek to characterize the possible transitions between states, their occurrence probabilities, or to predict the trajectory of future patients - all conditioned on various baseline and time-varying individual covariates. By fitting a multi-state model, we can learn the hazard for each specific transition, which would later be used to predict future paths. Predicting paths could be used at a single patient level, for example predict how long until a cancer patient will be relapse-free given his current health status, or at what probability will a patient end a trajectory at any of the possible states; and at the population level, for example predicting how many patients which arrive at the emergency-room will need to be admitted, given their covariates. Capabilities \u00a4 PyMSM is a Python package for fitting multi-state models, with a simple API which allows user-defined models, predictions at a single or population sample level, and statistical summaries and figures. Features of this software include: - Fitting a Competing risks Multistate model based on various types of survival analysis (time-to-event) such as Cox proportional hazards models or machine learning models, while taking into account right censoring, competing events, recurrent events, left truncation, and time-dependent covariates. - Running Monte-carlo simulations (in parallel computation) for paths emitted by the trained model and extracting various summary statistics and plots. - Loading or configuring a pre-defined model and generating simulated data in terms of random paths using model parameters, which could be highly useful as a research tool. - Modularity and compatibility for different time-to-event models such as Survival Forests and other custom ML models provided by the user. The package is designed to allow modular usage by both experienced researchers and non-expert users. In addition to fitting a multi-state model for a given data - PyMSM allows the user to simulate trajectories, thus creating a multi-state data-set, from a predefined model. This could be a valuable research tool - both for sharing sensitive simulated individual data and as a tool for any downstream task which needs individual trajectories. Citation \u00a4 If you found this library useful in academic research, please cite: @article { Rossman2022 , doi = {10.21105/joss.04566} , url = {https://doi.org/10.21105/joss.04566} , year = {2022} , author = {Hagai Rossman and Ayya Keshet and Malka Gorfine} , title = {PyMSM: Python package for Competing Risks and Multi-State models for Survival Data} , journal = {Journal of Open Source Software} } Also consider starring the project on GitHub This project is based on methods first introduced by the authors of Roimi et. al. 2021 . Original R code by Jonathan Somer, Asaf Ben Arie, Rom Gutman, Uri Shalit & Malka Gorfine available here . Also see Rossman & Meir et. al. 2021 for an application of this model on COVID-19 hospitalizations data.","title":"PyMSM in a nutshell"},{"location":"#pymsm-in-a-nutshell","text":"Hagai Rossman , Ayya Keshet , Malka Gorfine 2022 PyMSM is a Python package for fitting competing risks and multistate models, with a simple API which allows user-defined model, predictions at a single or population sample level, statistical summaries and figures. Features include: Fit a Competing risks Multistate model based on survival analysis (time-to-event) models. Deals with right censoring, competing events, recurrent events, left truncation, and time-dependent covariates. Run Monte-carlo simulations for paths emitted by the trained model and extract various summary statistics and plots. Load or configure a pre-defined model and run path simulations. Modularity and compatibility for different time-to-event models such as Survival Forests and other custom models.","title":"PyMSM in a nutshell"},{"location":"#installation","text":"pip install pymsm Requires Python >=3.8","title":"Installation"},{"location":"#quick-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Load data (See Rotterdam example for full details) from pymsm.datasets import prep_rotterdam dataset , states_labels = prep_rotterdam () # Define terminal states terminal_states = [ 3 ] #Init MultistateModel from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset , terminal_states ) # Fit model to data multi_state_model . fit () # Run Monte-Carlo simulation and sample paths mcs = multi_state_model . run_monte_carlo_simulation ( sample_covariates = dataset [ 0 ] . covariates . values , origin_state = 1 , current_time = 0 , max_transitions = 2 , n_random_samples = 10 , print_paths = True ) stateDiagram-v2 s1 : (1) Primary surgery s2 : (2) Disease recurrence s3 : (3) Death s1 --> s2: 1518 s1 --> s3: 195 s2 --> s3: 1077","title":"Quick example"},{"location":"#background-and-motivation","text":"Multi-state data are common, and could be used to describe trajectories in diverse health applications; such as describing a patient's progression through disease stages or a patient\u2019s path through different hospitalization states. When faced with such data, a researcher or clinician might seek to characterize the possible transitions between states, their occurrence probabilities, or to predict the trajectory of future patients - all conditioned on various baseline and time-varying individual covariates. By fitting a multi-state model, we can learn the hazard for each specific transition, which would later be used to predict future paths. Predicting paths could be used at a single patient level, for example predict how long until a cancer patient will be relapse-free given his current health status, or at what probability will a patient end a trajectory at any of the possible states; and at the population level, for example predicting how many patients which arrive at the emergency-room will need to be admitted, given their covariates.","title":"Background and Motivation"},{"location":"#capabilities","text":"PyMSM is a Python package for fitting multi-state models, with a simple API which allows user-defined models, predictions at a single or population sample level, and statistical summaries and figures. Features of this software include: - Fitting a Competing risks Multistate model based on various types of survival analysis (time-to-event) such as Cox proportional hazards models or machine learning models, while taking into account right censoring, competing events, recurrent events, left truncation, and time-dependent covariates. - Running Monte-carlo simulations (in parallel computation) for paths emitted by the trained model and extracting various summary statistics and plots. - Loading or configuring a pre-defined model and generating simulated data in terms of random paths using model parameters, which could be highly useful as a research tool. - Modularity and compatibility for different time-to-event models such as Survival Forests and other custom ML models provided by the user. The package is designed to allow modular usage by both experienced researchers and non-expert users. In addition to fitting a multi-state model for a given data - PyMSM allows the user to simulate trajectories, thus creating a multi-state data-set, from a predefined model. This could be a valuable research tool - both for sharing sensitive simulated individual data and as a tool for any downstream task which needs individual trajectories.","title":"Capabilities"},{"location":"#citation","text":"If you found this library useful in academic research, please cite: @article { Rossman2022 , doi = {10.21105/joss.04566} , url = {https://doi.org/10.21105/joss.04566} , year = {2022} , author = {Hagai Rossman and Ayya Keshet and Malka Gorfine} , title = {PyMSM: Python package for Competing Risks and Multi-State models for Survival Data} , journal = {Journal of Open Source Software} } Also consider starring the project on GitHub This project is based on methods first introduced by the authors of Roimi et. al. 2021 . Original R code by Jonathan Somer, Asaf Ben Arie, Rom Gutman, Uri Shalit & Malka Gorfine available here . Also see Rossman & Meir et. al. 2021 for an application of this model on COVID-19 hospitalizations data.","title":"Citation"},{"location":"methods/","text":"Methods \u00a4 Under Construction In this section we give an overview of the models and methods underlying the statistics and computations performed in PyMSM . Introduction \u00a4 PyMSM fits and predicts based on a multistate model supplied by the user. Some examples of multistate models: 1) A simple competing-risk form with three states, \\(A,B,C\\) and two possible transitions, \\(A \\rightarrow B\\) and \\(A \\rightarrow C\\) . stateDiagram-v2 A --> B A --> C 2) An illness-death model with the same three states but three possible transitions \\(A \\rightarrow B\\) , \\(A \\rightarrow C\\) and \\(B \\rightarrow C\\) . stateDiagram-v2 A --> B A --> C B --> C 3) Or any other more involved multistate framework (add figures of these models). The description of the content of PyMSM would be easier to digest under a certain setting. Thus, to set the stage, we adopt the multistate model of Roimi et. al. (2021) . Specifically, assume a multi-state model consists of four states \\(A,B,C,D\\) and six possible transitions: $$ A \\rightarrow B \\,\\,\\,\\,\\,\\, A \\rightarrow C \\,\\,\\,\\,\\,\\, A \\rightarrow D \\,\\,\\,\\,\\,\\, B \\rightarrow A \\,\\,\\,\\,\\,\\, B \\rightarrow D \\,\\,\\,\\,\\,\\, C \\rightarrow A \\, . $$ stateDiagram-v2 A --> B A --> C A --> D B --> A B --> D C --> A Each transition is characterizes by a transition-specific hazard function, also known as a cause-specific hazard function, $$ \\lambda_{A,B} (t|Z) \\,\\,\\, \\lambda_{A,C} (t|Z) \\,\\,\\, \\lambda_{A,D} (t|Z) \\,\\,\\, \\lambda_{B,A} (t|Z) \\,\\,\\, \\lambda_{B,D} (t|Z) \\,\\,\\, \\lambda_{C,A} (t|Z) \\, $$ for \\(t > 0\\) and \\(Z\\) vector of covariates. Although \\(Z\\) is shared by the six models above, it does not imply that identical covariates must be used in these models. For example, in Cox models with transition-dependent regression coefficient vectors, one can set any specific coefficient to 0 for excluding the corresponding covariate. Let \\(J_C\\) and \\(J_N\\) denote the current and next states, respectively, and \\(T\\) denotes the transition time. Assume the journey of an observation in the system described by the multi-state model starts at state \\(j^*\\) with vector of baseline covariates \\(W\\) . Let \\(Z(t)\\) be a time-dependent vector of covariates, where $$ Z(t) = (W^T,\\widetilde{W}(t)) $$ and \\(\\widetilde{W}(t)\\) is a time-dependent vector of covariates known at the entrance to the new state. Let \\(K_{j^*}\\) be the set of possible states that can be reached directly from state \\(j^*\\) . Then, the conditional probability of transition \\(j^* \\rightarrow j\\) , \\(j \\in K_{j^*}\\) , by time \\(t\\) given \\(Z(0)=Z\\) is given by $$ \\Pr(T \\leq t, J_N=j|J_C=j^ ,Z(0)=Z) = \\int_0^t \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du \\, , $$ where \\(u-\\) is a time just prior to \\(u\\) , \\(|K_{j^*}|\\) is the cardinality of \\(K_{j^*}\\) and \\(\\Lambda_{j,k}(t|Z)=\\int_0^t \\lambda_{j,k}(u|Z) du\\) is the cumulative hazard function. In our example, if the first state \\(j^*=A\\) , \\(K_{j^*}=\\{B,C,D\\}\\) , and \\[ \\Pr(T \\leq t, J_N=j|J_C=A,Z(0)=Z) = $$ $$ \\int_0^t \\lambda_{A,j}(u|Z)\\exp\\left\\{- \\Lambda_{A,B}(u-|Z) - \\Lambda_{A,C}(u-|Z) - \\Lambda_{A,D}(u-|Z)\\right\\} du \\, , \\] The marginal probability of transition \\(j^* \\rightarrow j\\) is given by $$ \\Pr(J_N=j|J_C=j^ ,Z(0)=Z) = \\int_0^\\infty \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du \\, , $$ and the probability of transition time less than \\(t\\) given a transition \\(j^* \\rightarrow j\\) $$ \\Pr(T \\leq t | J_N=j,J_C=j^ , Z(0)=Z) = \\frac{ \\int_0^t \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du } { \\int_0^\\infty \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^*,k}(u-|Z) \\right} du } \\, . $$ Now assume an observation entered state \\(j'\\) at time \\(t'>0\\) with \\(Z(t')\\) . Then, the probability of \\(j' \\rightarrow j\\) by time \\(t\\) is given by $$ \\Pr(T \\leq t, J_N=j|J_C=j',Z(t')=Z) = \\int_{t'}^t \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du \\, , $$ and $$ \\Pr(T \\leq t| J_N=j,J_C=j',Z(t')=Z) = \\frac{ \\int_{t'}^t \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du } { \\int_{t'}^\\infty \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du } \\, . $$ All the above, set the main multi-state model components required for prediction, as will be explained in the following sections. Estimation \u00a4 Cox transition-specific hazard models \u00a4 The estimation procedure for the hazard functions that define the multi-state model can be chosen by the user. For example, if Cox models are adopted, where each transition \\(j \\rightarrow j'\\) consists of transition-specific unspecified baseline hazard function \\(\\lambda_{0j,j'}(\\cdot)\\) and a transition-specific vector of regression coefficients \\(\\beta_{j,j'}\\) , i.e., $$ \\lambda_{j,j'}(t|Z) = \\lambda_{0j,j'}(t) \\exp(Z^T \\beta_{j,j'}) \\, , $$ the estimation procedure is straightforward. Specifically, under transition-specific semi-parametric Cox models, we can easily deal with: - Right censoring and competing events based on the approach of [@Andersen:1991]. Namely, maximization of the likelihood function in terms of all the involved Cox models is done by maximizing the likelihood of each transition separately. Thus, we use the standard partial likelihood estimators of \\(\\beta_{j,j'}\\) [@Klein:2006] and Breslow estimator of \\(\\Lambda_{0j,j'}(t)=\\int_0^t \\lambda_{0j,j'}(u)du\\) (Breslow, 1972). - Left truncation which occurs at each transition that is not the origin state of the subject's path. Bias due to left truncation is eliminated by using the well-known risk-set correction [@Klein:2006]. - Recurrent events which occurs when subjects visit the same state multiple times. In such cases, the robust standard errors account for correlated outcomes within a subject [@Andersen:1982]. Based on the estimates of the regression coefficients and the cumulative baseline hazard functions all the distribution functions in the introduction section can be estimated by replacing the integrals with sums over the observed failure time, and any unknown parameter is replaced by its estimator. Specifically, let \\(\\tau_{j^*,j}\\) be the largest observed event time of transition \\(j^* \\rightarrow j\\) . Then, \\begin{equation} \\begin{aligned} \\widehat{\\Pr} (J_N=j | J_C=j^ ,Z(0)=Z) \\ = \\sum_{t_m \\leq \\tau_{j^ ,j}} \\exp\\left( \\widehat\\beta_{j^ ,j}^T Z\\right) \\widehat\\lambda_{0j^ ,j}(t_m) \\exp \\left{-\\sum_{k=1}^{|K_{j^ }|} \\widehat\\Lambda_{0j^ ,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*,k}^T Z\\right) \\right} \\, , \\end{aligned} \\end{equation} \\[\\begin{equation} \\begin{aligned} \\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^* , Z(0)=Z)\\\\ \\hspace{0.5cm} = \\frac{\\sum_{t_m \\leq t} \\exp\\left( \\widehat\\beta_{j^*,j'}^T Z\\right) \\widehat\\lambda_{0j^*,j'}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j^*}|} \\widehat\\Lambda_{0j^*,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*k}^T Z\\right) \\right\\} }{ \\sum_{t_m \\leq \\tau_{j^*,j'}} \\exp\\left( \\widehat\\beta_{j^*,j'}^T Z\\right) \\widehat\\lambda_{0j^*,j'}(t_m) \\exp \\left\\{-\\sum_{k=1}^{K_{j^*}} \\widehat\\Lambda_{0j^*,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*,k}^T Z\\right) \\right\\} } \\, , \\end{aligned} \\end{equation} and finally, given a new $\\breve{j}$, the estimated probability of staying at state $j'$ less than or equal $t$ time unit is given by \\begin{equation} \\begin{aligned} \\widehat{\\Pr} (T\\leq t| J_N=\\breve{j}, J_C=j' , Z(t')=Z) \\\\ \\hspace{0.5cm} = \\frac{\\sum_{t' < t_m \\leq t} \\exp\\left( \\widehat\\beta_{j',\\breve{j}}^T Z\\right) \\widehat\\lambda_{0j',\\breve{j}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} }{ \\sum_{t' < t_m \\leq \\tau_{j',\\breve{j}}} \\exp\\left( \\widehat\\beta_{j',\\breve{j}}^T Z\\right) \\widehat\\lambda_{0j',\\breve{j}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{K_{j'}} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} } \\, . \\end{aligned} \\end{equation}\\] Other transition-specific models \u00a4 Similarly, the user can define other survival models and estimation procedure, such as accelerated failure time model, random survival forests (ref) etc, for each transition, as explained in section Costume Fitters above. Prediction - Monte Carlo Simulation \u00a4 Based on the multi-state model, we reconstruct the complete distribution of the path for a new observation, given the observed covariates \\(W\\) . Based on the reconstructed distribution we estimate - The probability of visiting each state. - The total length of stay at each state. - The total length of stay in the entire system. The above quantities can be predicted before entering the system and also during the stay at one of the systems' states, while correctly taking into account the accumulated time already spent in the system and \\(Z(\\cdot)\\) . We reconstruct the distribution of the path for a new observation by Monte-Carlo simulation. Assume the starting state (provided by the user) is \\(j^*\\) . Then, the next state \\(J_N\\) is sampled based on the discrete conditional probabilities $$ p_{j|j^ ,Z}= \\frac{\\widehat{\\Pr} (J_N=j | J_C=j^ , Z(0)=Z) }{\\sum_{j'=1}^{K_{j^ }} \\widehat{\\Pr} (J_N=j' | J_C=j^ , Z(0)=Z)} \\, . $$ where \\(j \\in K_{j^*}\\) and the summation is over the distinct observed event times of transition \\(j^* \\rightarrow j\\) . Once we sampled the next state, denoted by \\(j'\\) , the time to be spent at state \\(j^*\\) is sampled based on $$ \\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^ , Z(0)=Z) \\, . $$ This is done by sampling \\(U \\sim Uniform[0,1]\\) , equating $$ U=\\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^ , Z(0)=Z) $$ and solving for \\(t\\) . Denote the sampled time by \\(t'\\) and update \\(Z(t')\\) . In case \\(j'\\) , is a terminal state, the sampling path ends here. Otherwise, the current state is updated to \\(J_C=j'\\) , and the following state is sampled by \\(p_{j|j',Z(t')}\\) , \\(j=1 \\in K_{j'}\\) , $$ p_{ j|j',Z}= \\frac{\\sum_{t' < t_m \\leq \\tau_{j',j}} \\exp\\left( \\widehat\\beta_{j',j}^T Z\\right) \\widehat\\lambda_{0j',j}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} } {\\sum_{j^{**}=1}^{K_{j'}} \\sum_{t' < t_m \\leq \\tau_{j',j^{**}}} \\exp\\left( \\widehat\\beta_{j',j^{**}}^T Z\\right) \\widehat\\lambda_{0j',j^{**}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\}} \\, . $$ Generating Random Multistate Survival Data \u00a4 PyMSM allows the user to predefine a model by providing an input of transition-specific baseline hazards and hazard coefficients \\(\\beta_{j,j'}\\) , and a time-varying covariates update function if needed. After providing this information, the user can then simulate trajectories, thus creating a new multi-state data-set which may be valuable for a variety of purposes. \\[ \\Pr(T \\leq t, J_N=j|J_C=j^*,Z(0)=Z) = \\int_0^t \\lambda_{j^*,j}(u|Z)\\exp\\left\\{-\\sum_{k=1}^{|K_{j^*}|} \\Lambda_{j^*,k}(u-|Z) \\right\\}du \\]","title":"Methods"},{"location":"methods/#methods","text":"Under Construction In this section we give an overview of the models and methods underlying the statistics and computations performed in PyMSM .","title":"Methods"},{"location":"methods/#introduction","text":"PyMSM fits and predicts based on a multistate model supplied by the user. Some examples of multistate models: 1) A simple competing-risk form with three states, \\(A,B,C\\) and two possible transitions, \\(A \\rightarrow B\\) and \\(A \\rightarrow C\\) . stateDiagram-v2 A --> B A --> C 2) An illness-death model with the same three states but three possible transitions \\(A \\rightarrow B\\) , \\(A \\rightarrow C\\) and \\(B \\rightarrow C\\) . stateDiagram-v2 A --> B A --> C B --> C 3) Or any other more involved multistate framework (add figures of these models). The description of the content of PyMSM would be easier to digest under a certain setting. Thus, to set the stage, we adopt the multistate model of Roimi et. al. (2021) . Specifically, assume a multi-state model consists of four states \\(A,B,C,D\\) and six possible transitions: $$ A \\rightarrow B \\,\\,\\,\\,\\,\\, A \\rightarrow C \\,\\,\\,\\,\\,\\, A \\rightarrow D \\,\\,\\,\\,\\,\\, B \\rightarrow A \\,\\,\\,\\,\\,\\, B \\rightarrow D \\,\\,\\,\\,\\,\\, C \\rightarrow A \\, . $$ stateDiagram-v2 A --> B A --> C A --> D B --> A B --> D C --> A Each transition is characterizes by a transition-specific hazard function, also known as a cause-specific hazard function, $$ \\lambda_{A,B} (t|Z) \\,\\,\\, \\lambda_{A,C} (t|Z) \\,\\,\\, \\lambda_{A,D} (t|Z) \\,\\,\\, \\lambda_{B,A} (t|Z) \\,\\,\\, \\lambda_{B,D} (t|Z) \\,\\,\\, \\lambda_{C,A} (t|Z) \\, $$ for \\(t > 0\\) and \\(Z\\) vector of covariates. Although \\(Z\\) is shared by the six models above, it does not imply that identical covariates must be used in these models. For example, in Cox models with transition-dependent regression coefficient vectors, one can set any specific coefficient to 0 for excluding the corresponding covariate. Let \\(J_C\\) and \\(J_N\\) denote the current and next states, respectively, and \\(T\\) denotes the transition time. Assume the journey of an observation in the system described by the multi-state model starts at state \\(j^*\\) with vector of baseline covariates \\(W\\) . Let \\(Z(t)\\) be a time-dependent vector of covariates, where $$ Z(t) = (W^T,\\widetilde{W}(t)) $$ and \\(\\widetilde{W}(t)\\) is a time-dependent vector of covariates known at the entrance to the new state. Let \\(K_{j^*}\\) be the set of possible states that can be reached directly from state \\(j^*\\) . Then, the conditional probability of transition \\(j^* \\rightarrow j\\) , \\(j \\in K_{j^*}\\) , by time \\(t\\) given \\(Z(0)=Z\\) is given by $$ \\Pr(T \\leq t, J_N=j|J_C=j^ ,Z(0)=Z) = \\int_0^t \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du \\, , $$ where \\(u-\\) is a time just prior to \\(u\\) , \\(|K_{j^*}|\\) is the cardinality of \\(K_{j^*}\\) and \\(\\Lambda_{j,k}(t|Z)=\\int_0^t \\lambda_{j,k}(u|Z) du\\) is the cumulative hazard function. In our example, if the first state \\(j^*=A\\) , \\(K_{j^*}=\\{B,C,D\\}\\) , and \\[ \\Pr(T \\leq t, J_N=j|J_C=A,Z(0)=Z) = $$ $$ \\int_0^t \\lambda_{A,j}(u|Z)\\exp\\left\\{- \\Lambda_{A,B}(u-|Z) - \\Lambda_{A,C}(u-|Z) - \\Lambda_{A,D}(u-|Z)\\right\\} du \\, , \\] The marginal probability of transition \\(j^* \\rightarrow j\\) is given by $$ \\Pr(J_N=j|J_C=j^ ,Z(0)=Z) = \\int_0^\\infty \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du \\, , $$ and the probability of transition time less than \\(t\\) given a transition \\(j^* \\rightarrow j\\) $$ \\Pr(T \\leq t | J_N=j,J_C=j^ , Z(0)=Z) = \\frac{ \\int_0^t \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^ ,k}(u-|Z) \\right} du } { \\int_0^\\infty \\lambda_{j^ ,j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j^ }|} \\Lambda_{j^*,k}(u-|Z) \\right} du } \\, . $$ Now assume an observation entered state \\(j'\\) at time \\(t'>0\\) with \\(Z(t')\\) . Then, the probability of \\(j' \\rightarrow j\\) by time \\(t\\) is given by $$ \\Pr(T \\leq t, J_N=j|J_C=j',Z(t')=Z) = \\int_{t'}^t \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du \\, , $$ and $$ \\Pr(T \\leq t| J_N=j,J_C=j',Z(t')=Z) = \\frac{ \\int_{t'}^t \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du } { \\int_{t'}^\\infty \\lambda_{j',j}(u|Z)\\exp\\left{-\\sum_{k=1}^{|K_{j'}|} \\Lambda_{j',k}(u-|Z) \\right} du } \\, . $$ All the above, set the main multi-state model components required for prediction, as will be explained in the following sections.","title":"Introduction"},{"location":"methods/#estimation","text":"","title":"Estimation"},{"location":"methods/#cox-transition-specific-hazard-models","text":"The estimation procedure for the hazard functions that define the multi-state model can be chosen by the user. For example, if Cox models are adopted, where each transition \\(j \\rightarrow j'\\) consists of transition-specific unspecified baseline hazard function \\(\\lambda_{0j,j'}(\\cdot)\\) and a transition-specific vector of regression coefficients \\(\\beta_{j,j'}\\) , i.e., $$ \\lambda_{j,j'}(t|Z) = \\lambda_{0j,j'}(t) \\exp(Z^T \\beta_{j,j'}) \\, , $$ the estimation procedure is straightforward. Specifically, under transition-specific semi-parametric Cox models, we can easily deal with: - Right censoring and competing events based on the approach of [@Andersen:1991]. Namely, maximization of the likelihood function in terms of all the involved Cox models is done by maximizing the likelihood of each transition separately. Thus, we use the standard partial likelihood estimators of \\(\\beta_{j,j'}\\) [@Klein:2006] and Breslow estimator of \\(\\Lambda_{0j,j'}(t)=\\int_0^t \\lambda_{0j,j'}(u)du\\) (Breslow, 1972). - Left truncation which occurs at each transition that is not the origin state of the subject's path. Bias due to left truncation is eliminated by using the well-known risk-set correction [@Klein:2006]. - Recurrent events which occurs when subjects visit the same state multiple times. In such cases, the robust standard errors account for correlated outcomes within a subject [@Andersen:1982]. Based on the estimates of the regression coefficients and the cumulative baseline hazard functions all the distribution functions in the introduction section can be estimated by replacing the integrals with sums over the observed failure time, and any unknown parameter is replaced by its estimator. Specifically, let \\(\\tau_{j^*,j}\\) be the largest observed event time of transition \\(j^* \\rightarrow j\\) . Then, \\begin{equation} \\begin{aligned} \\widehat{\\Pr} (J_N=j | J_C=j^ ,Z(0)=Z) \\ = \\sum_{t_m \\leq \\tau_{j^ ,j}} \\exp\\left( \\widehat\\beta_{j^ ,j}^T Z\\right) \\widehat\\lambda_{0j^ ,j}(t_m) \\exp \\left{-\\sum_{k=1}^{|K_{j^ }|} \\widehat\\Lambda_{0j^ ,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*,k}^T Z\\right) \\right} \\, , \\end{aligned} \\end{equation} \\[\\begin{equation} \\begin{aligned} \\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^* , Z(0)=Z)\\\\ \\hspace{0.5cm} = \\frac{\\sum_{t_m \\leq t} \\exp\\left( \\widehat\\beta_{j^*,j'}^T Z\\right) \\widehat\\lambda_{0j^*,j'}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j^*}|} \\widehat\\Lambda_{0j^*,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*k}^T Z\\right) \\right\\} }{ \\sum_{t_m \\leq \\tau_{j^*,j'}} \\exp\\left( \\widehat\\beta_{j^*,j'}^T Z\\right) \\widehat\\lambda_{0j^*,j'}(t_m) \\exp \\left\\{-\\sum_{k=1}^{K_{j^*}} \\widehat\\Lambda_{0j^*,k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j^*,k}^T Z\\right) \\right\\} } \\, , \\end{aligned} \\end{equation} and finally, given a new $\\breve{j}$, the estimated probability of staying at state $j'$ less than or equal $t$ time unit is given by \\begin{equation} \\begin{aligned} \\widehat{\\Pr} (T\\leq t| J_N=\\breve{j}, J_C=j' , Z(t')=Z) \\\\ \\hspace{0.5cm} = \\frac{\\sum_{t' < t_m \\leq t} \\exp\\left( \\widehat\\beta_{j',\\breve{j}}^T Z\\right) \\widehat\\lambda_{0j',\\breve{j}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} }{ \\sum_{t' < t_m \\leq \\tau_{j',\\breve{j}}} \\exp\\left( \\widehat\\beta_{j',\\breve{j}}^T Z\\right) \\widehat\\lambda_{0j',\\breve{j}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{K_{j'}} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} } \\, . \\end{aligned} \\end{equation}\\]","title":"Cox transition-specific hazard models"},{"location":"methods/#other-transition-specific-models","text":"Similarly, the user can define other survival models and estimation procedure, such as accelerated failure time model, random survival forests (ref) etc, for each transition, as explained in section Costume Fitters above.","title":"Other transition-specific models"},{"location":"methods/#prediction-monte-carlo-simulation","text":"Based on the multi-state model, we reconstruct the complete distribution of the path for a new observation, given the observed covariates \\(W\\) . Based on the reconstructed distribution we estimate - The probability of visiting each state. - The total length of stay at each state. - The total length of stay in the entire system. The above quantities can be predicted before entering the system and also during the stay at one of the systems' states, while correctly taking into account the accumulated time already spent in the system and \\(Z(\\cdot)\\) . We reconstruct the distribution of the path for a new observation by Monte-Carlo simulation. Assume the starting state (provided by the user) is \\(j^*\\) . Then, the next state \\(J_N\\) is sampled based on the discrete conditional probabilities $$ p_{j|j^ ,Z}= \\frac{\\widehat{\\Pr} (J_N=j | J_C=j^ , Z(0)=Z) }{\\sum_{j'=1}^{K_{j^ }} \\widehat{\\Pr} (J_N=j' | J_C=j^ , Z(0)=Z)} \\, . $$ where \\(j \\in K_{j^*}\\) and the summation is over the distinct observed event times of transition \\(j^* \\rightarrow j\\) . Once we sampled the next state, denoted by \\(j'\\) , the time to be spent at state \\(j^*\\) is sampled based on $$ \\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^ , Z(0)=Z) \\, . $$ This is done by sampling \\(U \\sim Uniform[0,1]\\) , equating $$ U=\\widehat{\\Pr} (T\\leq t| J_N=j', J_C=j^ , Z(0)=Z) $$ and solving for \\(t\\) . Denote the sampled time by \\(t'\\) and update \\(Z(t')\\) . In case \\(j'\\) , is a terminal state, the sampling path ends here. Otherwise, the current state is updated to \\(J_C=j'\\) , and the following state is sampled by \\(p_{j|j',Z(t')}\\) , \\(j=1 \\in K_{j'}\\) , $$ p_{ j|j',Z}= \\frac{\\sum_{t' < t_m \\leq \\tau_{j',j}} \\exp\\left( \\widehat\\beta_{j',j}^T Z\\right) \\widehat\\lambda_{0j',j}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\} } {\\sum_{j^{**}=1}^{K_{j'}} \\sum_{t' < t_m \\leq \\tau_{j',j^{**}}} \\exp\\left( \\widehat\\beta_{j',j^{**}}^T Z\\right) \\widehat\\lambda_{0j',j^{**}}(t_m) \\exp \\left\\{-\\sum_{k=1}^{|K_{j'}|} \\widehat\\Lambda_{0j',k}(t_{m-1})\\exp\\left( \\widehat\\beta_{j',k}^T Z\\right) \\right\\}} \\, . $$","title":"Prediction - Monte Carlo Simulation"},{"location":"methods/#generating-random-multistate-survival-data","text":"PyMSM allows the user to predefine a model by providing an input of transition-specific baseline hazards and hazard coefficients \\(\\beta_{j,j'}\\) , and a time-varying covariates update function if needed. After providing this information, the user can then simulate trajectories, thus creating a new multi-state data-set which may be valuable for a variety of purposes. \\[ \\Pr(T \\leq t, J_N=j|J_C=j^*,Z(0)=Z) = \\int_0^t \\lambda_{j^*,j}(u|Z)\\exp\\left\\{-\\sum_{k=1}^{|K_{j^*}|} \\Lambda_{j^*,k}(u-|Z) \\right\\}du \\]","title":"Generating Random Multistate Survival Data"},{"location":"api/multistate_model/","text":"This class fits a competing risks model per state, that is, it treats all state transitions as competing risks. See the CompetingRisksModel class Parameters: Name Type Description Default dataset Union[List[PathObject], DataFrame] either a list of PathObject or a pandas data frame in the format used to fit the CompetingRiskModel class. Dataset used to fit a competing risk model to each state required terminal_states List[int] States which a sample does not leave required update_covariates_fn Callable[ [Series, int, int, float, float], Series ] A state-transition function, which updates the time dependent variables. This function is used in fitting the model so that the user doesn't have to manually compute the features at each state, it is also used in the monte carlo method of predicting the survival curves per sample. Defaults to default_update_covariates_function. <function default_update_covariates_function at 0x7fb325cdaca0> covariate_names List[str] Optional list of covariate names to be used. Defaults to None. None event_specific_fitter EventSpecificFitter This class holds the model that will be fitter inside the CompetingRisksModel. Defaults to CoxWrapper. <class 'pymsm.event_specific_fitter.CoxWrapper'> competing_risk_data_format bool A boolean indicating the format of the dataset parmeter, if False - the dataset is assumed to be a list of PathObjects, if True - the dataset is assumed to be a dataframe which is compatible in format for fitting the CompetingRiskModel class. Defaults to False. False states_labels Dict[int, str] A dictionary of short state labels. Defaults to None. required trim_transitions_threshold int A threshold of the minimal number of transitions needed in the data to build a tranisition model. For transitions with less this number, no moedl will be built and data will be discarded. Defaults to 0. 0 Attributes: Name Type Description state_specific_models Dict[int, CompetingRisksModel] A dictionary of CompetingRisksModel objects, one for each state. Available after running the \"fit\" function. Note The update_covariates_fn could be any function you choose to write, but it needs to have the following parameter types (in this order): pandas Series, int, int, float, float; and return a pandas Series. Source code in pymsm/multi_state_competing_risks_model.py class MultiStateModel : \"\"\"This class fits a competing risks model per state, that is, it treats all state transitions as competing risks. See the CompetingRisksModel class Args: dataset (Union[List[PathObject], DataFrame]): either a list of PathObject or a pandas data frame in the format used to fit the CompetingRiskModel class. Dataset used to fit a competing risk model to each state terminal_states (List[int]): States which a sample does not leave update_covariates_fn (Callable[ [Series, int, int, float, float], Series ], optional): A state-transition function, which updates the time dependent variables. This function is used in fitting the model so that the user doesn't have to manually compute the features at each state, it is also used in the monte carlo method of predicting the survival curves per sample. Defaults to default_update_covariates_function. covariate_names (List[str], optional): Optional list of covariate names to be used. Defaults to None. event_specific_fitter (EventSpecificFitter, optional): This class holds the model that will be fitter inside the CompetingRisksModel. Defaults to CoxWrapper. competing_risk_data_format (bool, optional): A boolean indicating the format of the dataset parmeter, if False - the dataset is assumed to be a list of PathObjects, if True - the dataset is assumed to be a dataframe which is compatible in format for fitting the CompetingRiskModel class. Defaults to False. states_labels (Dict[int, str], optional): A dictionary of short state labels. Defaults to None. trim_transitions_threshold (int): A threshold of the minimal number of transitions needed in the data to build a tranisition model. For transitions with less this number, no moedl will be built and data will be discarded. Defaults to 0. Attributes: state_specific_models (Dict[int, CompetingRisksModel]): A dictionary of CompetingRisksModel objects, one for each state. Available after running the \"fit\" function. Note: The update_covariates_fn could be any function you choose to write, but it needs to have the following parameter types (in this order): pandas Series, int, int, float, float; and return a pandas Series. \"\"\" def __init__ ( self , dataset : Union [ List [ PathObject ], DataFrame ], terminal_states : List [ int ], update_covariates_fn : Callable [ [ Series , int , int , float , float ], Series ] = default_update_covariates_function , covariate_names : List [ str ] = None , event_specific_fitter : EventSpecificFitter = CoxWrapper , competing_risk_data_format : bool = False , state_labels : Dict [ int , str ] = None , trim_transitions_threshold : int = 0 , ): self . dataset = dataset self . terminal_states = terminal_states self . update_covariates_fn = update_covariates_fn self . covariate_names = self . _get_covariate_names ( covariate_names ) self . state_specific_models : Dict [ int , CompetingRisksModel ] = dict () self . _time_is_discrete : bool = None self . competing_risk_dataset : DataFrame = None self . _samples_have_weights : bool = False self . _competing_risk_data_format = competing_risk_data_format self . _event_specific_fitter = event_specific_fitter self . state_labels = state_labels self . trim_transitions_threshold = trim_transitions_threshold self . transition_matrix : DataFrame = None self . transition_table : DataFrame = None self . state_diagram_graph_string : str = None if self . _competing_risk_data_format : self . competing_risk_dataset = dataset if self . trim_transitions_threshold > 0 : self . _trim_transitions () else : self . _assert_valid_input () def fit ( self , verbose : int = 1 ) -> None : \"\"\"Fit a CompetingRiskModel for each state Args: verbose (int, optional): verbosity, by default 1. Defaults to 1. \"\"\" self . competing_risk_dataset = ( self . dataset if self . _competing_risk_data_format else self . _prepare_dataset_for_competing_risks_fit () ) self . _time_is_discrete = self . _check_if_time_is_discrete () for state in self . competing_risk_dataset [ \"origin_state\" ] . unique (): if verbose >= 1 : print ( \"Fitting Model at State: {} \" . format ( state )) model = self . _fit_state_specific_model ( state , verbose ) self . state_specific_models [ state ] = model if verbose >= 1 : self . plot_state_diagram () def _assert_valid_input ( self ) -> None : \"\"\"Checks that the dataset is valid for running the multi state competing risk model\"\"\" # Check the number of times is either equal or one less than the number of states for obj in self . dataset : n_states = len ( obj . states ) n_times = len ( obj . time_at_each_state ) assert n_states == n_times or n_states == n_times + 1 if n_states == 1 and obj . states [ 0 ] in self . terminal_states : obj . print_path () exit ( \"Error: encountered a sample with a single state that is a terminal state.\" ) # Check either all objects have an id or none has has_id = [ obj for obj in self . dataset if obj . sample_id is not None ] assert len ( has_id ) == len ( self . dataset ) or len ( has_id ) == 0 # Check either all objects have sample weight or none has has_weight = [ obj for obj in self . dataset if obj . sample_weight is not None ] assert len ( has_weight ) == len ( self . dataset ) or len ( has_weight ) == 0 self . _samples_have_weights = True if len ( has_weight ) > 0 else False # Check all covariates are of the same length cov_len = len ( self . dataset [ 0 ] . covariates ) same_length = [ obj for obj in self . dataset if len ( obj . covariates ) == cov_len ] assert len ( same_length ) == len ( self . dataset ) # Check length of covariate names matches the length of covariates in PathObject if self . covariate_names is None : return assert len ( self . covariate_names ) == len ( self . dataset [ 0 ] . covariates ) def _get_covariate_names ( self , covariate_names : List [ str ]) -> List [ str ]: \"\"\"This functions sets the covariate names that will be used in prints. Names are taken either from the given covariate names provided by the user, or if None provided - from the named pandas Series of covariates of the PathObject in the dataset Args: covariate_names (List[str], optional): covariate names provided in class init Returns: List: List of covariate names \"\"\" if covariate_names is not None : return covariate_names return self . dataset [ 0 ] . covariates . index . to_list () def _check_if_time_is_discrete ( self ) -> bool : \"\"\"This function check whether the time in the dataset is discrete\"\"\" times = ( self . competing_risk_dataset [ \"time_entry_to_origin\" ] . values . tolist () + self . competing_risk_dataset [ \"time_transition_to_target\" ] . values . tolist () ) if all ( isinstance ( t , int ) for t in times ): return True return False def _prepare_dataset_for_competing_risks_fit ( self ) -> DataFrame : \"\"\"This function converts the given dataset (list of PathObjects) to a pandas DataFrame that will be used when fitting the CompetingRiskModel class \"\"\" self . competing_risk_dataset = DataFrame () for obj in self . dataset : origin_state = obj . states [ 0 ] covs_entering_origin = Series ( dict ( zip ( self . covariate_names , obj . covariates . values )) ) time_entry_to_origin = 0 for i , state in enumerate ( obj . states ): transition_row = {} time_in_origin = obj . time_at_each_state [ i ] time_transition_to_target = time_entry_to_origin + time_in_origin target_state = ( obj . states [ i + 1 ] if i + 1 < len ( obj . states ) else RIGHT_CENSORING ) # append row corresponding to this transition transition_row [ \"sample_id\" ] = obj . sample_id if self . _samples_have_weights : transition_row [ \"sample_weight\" ] = obj . sample_weight transition_row [ \"origin_state\" ] = origin_state transition_row [ \"target_state\" ] = target_state transition_row [ \"time_entry_to_origin\" ] = time_entry_to_origin transition_row [ \"time_transition_to_target\" ] = time_transition_to_target transition_row . update ( covs_entering_origin . to_dict ()) self . competing_risk_dataset = pd . concat ( [ self . competing_risk_dataset , pd . DataFrame ([ transition_row ])], ignore_index = True , ) if ( target_state == RIGHT_CENSORING or target_state in self . terminal_states ): break else : # Set up for the next iteration covs_entering_origin = self . update_covariates_fn ( covs_entering_origin , origin_state , target_state , time_in_origin ) origin_state = target_state time_entry_to_origin = time_transition_to_target self . competing_risk_dataset [ \"sample_id\" ] = self . competing_risk_dataset [ \"sample_id\" ] . astype ( int ) self . competing_risk_dataset [ \"origin_state\" ] = self . competing_risk_dataset [ \"origin_state\" ] . astype ( int ) self . competing_risk_dataset [ \"target_state\" ] = self . competing_risk_dataset [ \"target_state\" ] . astype ( int ) # Create default state_labels if None provided if self . state_labels is None : unique_states = pd . unique ( self . competing_risk_dataset [ [ \"origin_state\" , \"target_state\" ] ] . values . ravel ( \"K\" ) ) # find unique possible states unique_states . sort () # sort unique_states = unique_states [ unique_states > 0 ] # drop censored self . state_labels = dict ( zip ( unique_states , [ str ( s ) for s in unique_states ]) ) # trim transitions if needed if self . trim_transitions_threshold > 0 : self . _trim_transitions () return self . competing_risk_dataset def prep_transition_table ( self ): \"\"\"This function creates a transition matrix from the dataset\"\"\" if self . competing_risk_dataset is None : self . _prepare_dataset_for_competing_risks_fit () # Create transition matrix self . transition_matrix = pd . crosstab ( self . competing_risk_dataset [ \"origin_state\" ], self . competing_risk_dataset [ \"target_state\" ], ) # Rename rows and columns and get a transition table self . transition_table = self . transition_matrix . copy () rename_dict = self . state_labels . copy () rename_dict [ 0 ] = \"Censored\" self . transition_table . rename ( columns = rename_dict , inplace = True ) self . transition_table . rename ( index = rename_dict , inplace = True ) return self . transition_table def _trim_transitions ( self ) -> None : \"\"\"For transitions with less than trim_transitions_threshold - discard data in competing_risk_dataset\"\"\" # copy orignal dataset for any future use self . _original_competing_risk_dataset = self . competing_risk_dataset . copy () if self . transition_matrix is None : self . prep_transition_table () # generate a list of tuples of transitions with less than trim_transitions_threshold i , j = np . where ( self . transition_matrix < self . trim_transitions_threshold ) invalid_transitions = list ( zip ( self . transition_matrix . index [ i ] . values , self . transition_matrix . columns [ j ] . values , ) ) # discard these tranisitons from competing risk dataset for origin_state , target_state in invalid_transitions : if origin_state == target_state : continue self . competing_risk_dataset = self . competing_risk_dataset [ ~ ( ( self . competing_risk_dataset [ \"origin_state\" ] == origin_state ) & ( self . competing_risk_dataset [ \"target_state\" ] == target_state ) ) ] # Update transition_table self . prep_transition_table () def extract_state_diagram_string_from_transition_table ( self ) -> str : \"\"\"This function extracts a mermaid state diagram string\"\"\" if self . transition_table is None : self . prep_transition_table () graph = \"\"\"stateDiagram-v2 \\n \"\"\" for s , state_label in self . state_labels . items (): graph += f \"\"\"s { s } : ( { s } ) { state_label } \\n \"\"\" for origin_state , row in self . transition_matrix . iterrows (): for target_state in row . index : if target_state == 0 : # Censored transition continue if row [ target_state ] == 0 : # Empty transition continue num_transitions = row [ target_state ] graph += ( f \"\"\"s { origin_state } --> s { target_state } : { num_transitions } \\n \"\"\" ) graph += \"\"\" \\n \"\"\" self . state_diagram_graph_string = graph def plot_state_diagram ( self ): \"\"\"This function plots a mermaid state diagram for the model\"\"\" if self . state_diagram_graph_string is None : self . extract_state_diagram_string_from_transition_table () return state_diagram ( self . state_diagram_graph_string ) def _fit_state_specific_model ( self , state : int , verbose : int = 1 ) -> CompetingRisksModel : \"\"\"Fit a CompetingRiskModel for a specific given state Args: state (int): State to fit the model for verbose (int, optional): verbosity. Defaults to 1. Returns: CompetingRisksModel: state specific model \"\"\" state_specific_df = self . competing_risk_dataset [ self . competing_risk_dataset [ \"origin_state\" ] == state ] . copy () state_specific_df . drop ([ \"origin_state\" ], axis = 1 , inplace = True ) state_specific_df . reset_index ( drop = True , inplace = True ) crm = CompetingRisksModel ( self . _event_specific_fitter ) crm . fit ( state_specific_df , event_col = \"target_state\" , duration_col = \"time_transition_to_target\" , cluster_col = \"sample_id\" , entry_col = \"time_entry_to_origin\" , verbose = verbose , ) return crm def _assert_valid_simulation_input ( self , sample_covariates : np . ndarray , origin_state : int , current_time : int , n_random_samples : int , max_transitions : int , n_jobs : int , print_paths : bool , ): \"\"\"This function checks if the input to the simulation is valid.\"\"\" # TODO assert valid inputs for sample_covariates (Series or np.ndarray, and length), origin_state assert current_time >= 0 assert isinstance ( n_random_samples , int ) assert n_random_samples > 0 assert isinstance ( max_transitions , int ) assert max_transitions > 0 assert isinstance ( print_paths , bool ) def run_monte_carlo_simulation ( self , sample_covariates : np . ndarray , # TODO change to np.ndarray OR pd.Series origin_state : int , current_time : int = 0 , n_random_samples : int = 100 , max_transitions : int = 10 , n_jobs : int = - 1 , print_paths : bool = False , ) -> List [ PathObject ]: \"\"\"This function samples random paths using Monte Carlo simulation. These paths will be used for prediction for a single sample. Initial sample covariates, along with the sample\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum. Args: sample_covariates (np.ndarray): Initial sample covariates, when entering the origin state origin_state (int): Initial state where the path begins from current_time (int, optional): Time when starting the sample path. Defaults to 0. n_random_samples (int, optional): Number of random paths to create. Defaults to 100. max_transitions (int, optional): Max number of transitions to allow in the paths. Defaults to 10. n_jobs (int, optional): Number of parallel jobs to run. Defaults to -1. print_paths (bool, optional): Whether to print the paths or not. Defaults to False. Returns: List[PathObject]: list of length n_random_samples, contining the randomly create PathObjects \"\"\" # Check input is valid self . _assert_valid_simulation_input ( sample_covariates , origin_state , current_time , n_random_samples , max_transitions , n_jobs , print_paths , ) if n_jobs is None : # no parallelization runs = [] for i in tqdm ( range ( 0 , n_random_samples )): runs . append ( self . _one_monte_carlo_run ( sample_covariates , origin_state , max_transitions , current_time ) ) else : # Run parallel jobs runs = Parallel ( n_jobs = n_jobs )( delayed ( self . _one_monte_carlo_run )( sample_covariates , origin_state , max_transitions , current_time ) for i in tqdm ( range ( 0 , n_random_samples )) ) if print_paths : self . _print_paths ( runs ) return runs def _one_monte_carlo_run ( self , sample_covariates : np . ndarray , origin_state : int , max_transitions : int , current_time : int = 0 , ) -> PathObject : \"\"\"This function create one path using Monte Carlo Simulations. See documentation of run_monte_carlo_simulation. \"\"\" run = PathObject ( states = list (), time_at_each_state = list ()) run . stopped_early = False current_state = origin_state for i in range ( 0 , max_transitions ): next_state = self . _sample_next_state ( current_state , sample_covariates , current_time ) if next_state is None : run . stopped_early = True return run time_to_next_state = self . _sample_time_to_next_state ( current_state , next_state , sample_covariates , current_time ) run . states . append ( current_state ) run . time_at_each_state . append ( time_to_next_state ) if next_state in self . terminal_states : run . states . append ( next_state ) break else : time_entry_to_target = current_state + time_to_next_state sample_covariates = self . update_covariates_fn ( sample_covariates , current_state , next_state , time_to_next_state , time_entry_to_target , ) current_state = next_state current_time = current_time + time_to_next_state return run def _probability_for_next_state ( self , next_state : int , competing_risks_model : CompetingRisksModel , sample_covariates : np . ndarray , t_entry_to_current_state : int = 0 , ): \"\"\"This function calculates the probability of transition to the next state, using the competing_risks_model model parameters \"\"\" unique_event_times = competing_risks_model . unique_event_times ( next_state ) if self . _time_is_discrete : mask = unique_event_times > np . floor ( t_entry_to_current_state + 1 ) else : mask = unique_event_times > t_entry_to_current_state # hazard for the failure type corresponding to 'state': hazard = competing_risks_model . hazard_at_unique_event_times ( sample_covariates , next_state ) hazard = hazard [ mask ] # overall survival function evaluated at time of failures corresponding to 'state' survival = competing_risks_model . survival_function ( unique_event_times [ mask ], sample_covariates ) probability_for_state = np . nansum ( hazard * survival ) return probability_for_state def _sample_next_state ( self , current_state : int , sample_covariates : np . ndarray , t_entry_to_current_state : int , ) -> Optional [ int ]: \"\"\"This function samples the next state, according to a multinomial distribution, using probabilites defines by _probability_for_next_state function. \"\"\" competing_risk_model = self . state_specific_models [ current_state ] possible_next_states = competing_risk_model . failure_types # compute probabilities for multinomial distribution probabilites = {} for state in possible_next_states : probabilites [ state ] = self . _probability_for_next_state ( state , competing_risk_model , sample_covariates , t_entry_to_current_state ) # when no transition after t_entry_to_current_state was seen if all ( value == 0 for value in probabilites . values ()): return None mult = np . random . multinomial ( 1 , list ( probabilites . values ())) next_state = possible_next_states [ mult . argmax ()] return next_state def _sample_time_to_next_state ( self , current_state : int , next_state : int , sample_covariates : np . ndarray , t_entry_to_current_state : int , ) -> float : \"\"\"This function samples the time of transition to the next state, using the hazard and survival provided by the competing risk model of the current_state \"\"\" competing_risk_model = self . state_specific_models [ current_state ] unique_event_times = competing_risk_model . unique_event_times ( next_state ) # ensure discrete variables are sampled from the next time unit if self . _time_is_discrete : mask = unique_event_times > np . floor ( t_entry_to_current_state + 1 ) else : mask = unique_event_times > t_entry_to_current_state unique_event_times = unique_event_times [ mask ] # hazard for the failure type corresponding to 'state' hazard = competing_risk_model . hazard_at_unique_event_times ( sample_covariates , next_state ) hazard = hazard [ mask ] # overall survival function evaluated at time of failures corresponding to 'state' survival = competing_risk_model . survival_function ( unique_event_times , sample_covariates ) probability_for_each_t = np . nancumsum ( hazard * survival ) probability_for_each_t_given_next_state = ( probability_for_each_t / probability_for_each_t . max () ) # take the first event time whose probability is less than or equal to eps # if we drew a very small eps, use the minimum observed time eps = np . random . uniform ( size = 1 ) possible_times = np . concatenate ( ( unique_event_times [ probability_for_each_t_given_next_state <= eps ], [ unique_event_times [ 0 ]], ) ) time_to_next_state = possible_times . max () time_to_next_state = time_to_next_state - t_entry_to_current_state return time_to_next_state def _print_paths ( self , mc_paths ): \"\"\"Helper function for printing the paths of a Monte Carlo simulation\"\"\" for mc_path in mc_paths : mc_path . print_path () print ( \" \\n \" ) extract_state_diagram_string_from_transition_table ( self ) \u00a4 This function extracts a mermaid state diagram string Source code in pymsm/multi_state_competing_risks_model.py def extract_state_diagram_string_from_transition_table ( self ) -> str : \"\"\"This function extracts a mermaid state diagram string\"\"\" if self . transition_table is None : self . prep_transition_table () graph = \"\"\"stateDiagram-v2 \\n \"\"\" for s , state_label in self . state_labels . items (): graph += f \"\"\"s { s } : ( { s } ) { state_label } \\n \"\"\" for origin_state , row in self . transition_matrix . iterrows (): for target_state in row . index : if target_state == 0 : # Censored transition continue if row [ target_state ] == 0 : # Empty transition continue num_transitions = row [ target_state ] graph += ( f \"\"\"s { origin_state } --> s { target_state } : { num_transitions } \\n \"\"\" ) graph += \"\"\" \\n \"\"\" self . state_diagram_graph_string = graph fit ( self , verbose = 1 ) \u00a4 Fit a CompetingRiskModel for each state Parameters: Name Type Description Default verbose int verbosity, by default 1. Defaults to 1. 1 Source code in pymsm/multi_state_competing_risks_model.py def fit ( self , verbose : int = 1 ) -> None : \"\"\"Fit a CompetingRiskModel for each state Args: verbose (int, optional): verbosity, by default 1. Defaults to 1. \"\"\" self . competing_risk_dataset = ( self . dataset if self . _competing_risk_data_format else self . _prepare_dataset_for_competing_risks_fit () ) self . _time_is_discrete = self . _check_if_time_is_discrete () for state in self . competing_risk_dataset [ \"origin_state\" ] . unique (): if verbose >= 1 : print ( \"Fitting Model at State: {} \" . format ( state )) model = self . _fit_state_specific_model ( state , verbose ) self . state_specific_models [ state ] = model if verbose >= 1 : self . plot_state_diagram () plot_state_diagram ( self ) \u00a4 This function plots a mermaid state diagram for the model Source code in pymsm/multi_state_competing_risks_model.py def plot_state_diagram ( self ): \"\"\"This function plots a mermaid state diagram for the model\"\"\" if self . state_diagram_graph_string is None : self . extract_state_diagram_string_from_transition_table () return state_diagram ( self . state_diagram_graph_string ) prep_transition_table ( self ) \u00a4 This function creates a transition matrix from the dataset Source code in pymsm/multi_state_competing_risks_model.py def prep_transition_table ( self ): \"\"\"This function creates a transition matrix from the dataset\"\"\" if self . competing_risk_dataset is None : self . _prepare_dataset_for_competing_risks_fit () # Create transition matrix self . transition_matrix = pd . crosstab ( self . competing_risk_dataset [ \"origin_state\" ], self . competing_risk_dataset [ \"target_state\" ], ) # Rename rows and columns and get a transition table self . transition_table = self . transition_matrix . copy () rename_dict = self . state_labels . copy () rename_dict [ 0 ] = \"Censored\" self . transition_table . rename ( columns = rename_dict , inplace = True ) self . transition_table . rename ( index = rename_dict , inplace = True ) return self . transition_table run_monte_carlo_simulation ( self , sample_covariates , origin_state , current_time = 0 , n_random_samples = 100 , max_transitions = 10 , n_jobs =- 1 , print_paths = False ) \u00a4 This function samples random paths using Monte Carlo simulation. These paths will be used for prediction for a single sample. Initial sample covariates, along with the sample\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum. Parameters: Name Type Description Default sample_covariates np.ndarray Initial sample covariates, when entering the origin state required origin_state int Initial state where the path begins from required current_time int Time when starting the sample path. Defaults to 0. 0 n_random_samples int Number of random paths to create. Defaults to 100. 100 max_transitions int Max number of transitions to allow in the paths. Defaults to 10. 10 n_jobs int Number of parallel jobs to run. Defaults to -1. -1 print_paths bool Whether to print the paths or not. Defaults to False. False Returns: Type Description List[PathObject] list of length n_random_samples, contining the randomly create PathObjects Source code in pymsm/multi_state_competing_risks_model.py def run_monte_carlo_simulation ( self , sample_covariates : np . ndarray , # TODO change to np.ndarray OR pd.Series origin_state : int , current_time : int = 0 , n_random_samples : int = 100 , max_transitions : int = 10 , n_jobs : int = - 1 , print_paths : bool = False , ) -> List [ PathObject ]: \"\"\"This function samples random paths using Monte Carlo simulation. These paths will be used for prediction for a single sample. Initial sample covariates, along with the sample\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum. Args: sample_covariates (np.ndarray): Initial sample covariates, when entering the origin state origin_state (int): Initial state where the path begins from current_time (int, optional): Time when starting the sample path. Defaults to 0. n_random_samples (int, optional): Number of random paths to create. Defaults to 100. max_transitions (int, optional): Max number of transitions to allow in the paths. Defaults to 10. n_jobs (int, optional): Number of parallel jobs to run. Defaults to -1. print_paths (bool, optional): Whether to print the paths or not. Defaults to False. Returns: List[PathObject]: list of length n_random_samples, contining the randomly create PathObjects \"\"\" # Check input is valid self . _assert_valid_simulation_input ( sample_covariates , origin_state , current_time , n_random_samples , max_transitions , n_jobs , print_paths , ) if n_jobs is None : # no parallelization runs = [] for i in tqdm ( range ( 0 , n_random_samples )): runs . append ( self . _one_monte_carlo_run ( sample_covariates , origin_state , max_transitions , current_time ) ) else : # Run parallel jobs runs = Parallel ( n_jobs = n_jobs )( delayed ( self . _one_monte_carlo_run )( sample_covariates , origin_state , max_transitions , current_time ) for i in tqdm ( range ( 0 , n_random_samples )) ) if print_paths : self . _print_paths ( runs ) return runs","title":"Multistate model"},{"location":"api/multistate_model/#pymsm.multi_state_competing_risks_model.MultiStateModel.extract_state_diagram_string_from_transition_table","text":"This function extracts a mermaid state diagram string Source code in pymsm/multi_state_competing_risks_model.py def extract_state_diagram_string_from_transition_table ( self ) -> str : \"\"\"This function extracts a mermaid state diagram string\"\"\" if self . transition_table is None : self . prep_transition_table () graph = \"\"\"stateDiagram-v2 \\n \"\"\" for s , state_label in self . state_labels . items (): graph += f \"\"\"s { s } : ( { s } ) { state_label } \\n \"\"\" for origin_state , row in self . transition_matrix . iterrows (): for target_state in row . index : if target_state == 0 : # Censored transition continue if row [ target_state ] == 0 : # Empty transition continue num_transitions = row [ target_state ] graph += ( f \"\"\"s { origin_state } --> s { target_state } : { num_transitions } \\n \"\"\" ) graph += \"\"\" \\n \"\"\" self . state_diagram_graph_string = graph","title":"extract_state_diagram_string_from_transition_table()"},{"location":"api/multistate_model/#pymsm.multi_state_competing_risks_model.MultiStateModel.fit","text":"Fit a CompetingRiskModel for each state Parameters: Name Type Description Default verbose int verbosity, by default 1. Defaults to 1. 1 Source code in pymsm/multi_state_competing_risks_model.py def fit ( self , verbose : int = 1 ) -> None : \"\"\"Fit a CompetingRiskModel for each state Args: verbose (int, optional): verbosity, by default 1. Defaults to 1. \"\"\" self . competing_risk_dataset = ( self . dataset if self . _competing_risk_data_format else self . _prepare_dataset_for_competing_risks_fit () ) self . _time_is_discrete = self . _check_if_time_is_discrete () for state in self . competing_risk_dataset [ \"origin_state\" ] . unique (): if verbose >= 1 : print ( \"Fitting Model at State: {} \" . format ( state )) model = self . _fit_state_specific_model ( state , verbose ) self . state_specific_models [ state ] = model if verbose >= 1 : self . plot_state_diagram ()","title":"fit()"},{"location":"api/multistate_model/#pymsm.multi_state_competing_risks_model.MultiStateModel.plot_state_diagram","text":"This function plots a mermaid state diagram for the model Source code in pymsm/multi_state_competing_risks_model.py def plot_state_diagram ( self ): \"\"\"This function plots a mermaid state diagram for the model\"\"\" if self . state_diagram_graph_string is None : self . extract_state_diagram_string_from_transition_table () return state_diagram ( self . state_diagram_graph_string )","title":"plot_state_diagram()"},{"location":"api/multistate_model/#pymsm.multi_state_competing_risks_model.MultiStateModel.prep_transition_table","text":"This function creates a transition matrix from the dataset Source code in pymsm/multi_state_competing_risks_model.py def prep_transition_table ( self ): \"\"\"This function creates a transition matrix from the dataset\"\"\" if self . competing_risk_dataset is None : self . _prepare_dataset_for_competing_risks_fit () # Create transition matrix self . transition_matrix = pd . crosstab ( self . competing_risk_dataset [ \"origin_state\" ], self . competing_risk_dataset [ \"target_state\" ], ) # Rename rows and columns and get a transition table self . transition_table = self . transition_matrix . copy () rename_dict = self . state_labels . copy () rename_dict [ 0 ] = \"Censored\" self . transition_table . rename ( columns = rename_dict , inplace = True ) self . transition_table . rename ( index = rename_dict , inplace = True ) return self . transition_table","title":"prep_transition_table()"},{"location":"api/multistate_model/#pymsm.multi_state_competing_risks_model.MultiStateModel.run_monte_carlo_simulation","text":"This function samples random paths using Monte Carlo simulation. These paths will be used for prediction for a single sample. Initial sample covariates, along with the sample\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum. Parameters: Name Type Description Default sample_covariates np.ndarray Initial sample covariates, when entering the origin state required origin_state int Initial state where the path begins from required current_time int Time when starting the sample path. Defaults to 0. 0 n_random_samples int Number of random paths to create. Defaults to 100. 100 max_transitions int Max number of transitions to allow in the paths. Defaults to 10. 10 n_jobs int Number of parallel jobs to run. Defaults to -1. -1 print_paths bool Whether to print the paths or not. Defaults to False. False Returns: Type Description List[PathObject] list of length n_random_samples, contining the randomly create PathObjects Source code in pymsm/multi_state_competing_risks_model.py def run_monte_carlo_simulation ( self , sample_covariates : np . ndarray , # TODO change to np.ndarray OR pd.Series origin_state : int , current_time : int = 0 , n_random_samples : int = 100 , max_transitions : int = 10 , n_jobs : int = - 1 , print_paths : bool = False , ) -> List [ PathObject ]: \"\"\"This function samples random paths using Monte Carlo simulation. These paths will be used for prediction for a single sample. Initial sample covariates, along with the sample\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum. Args: sample_covariates (np.ndarray): Initial sample covariates, when entering the origin state origin_state (int): Initial state where the path begins from current_time (int, optional): Time when starting the sample path. Defaults to 0. n_random_samples (int, optional): Number of random paths to create. Defaults to 100. max_transitions (int, optional): Max number of transitions to allow in the paths. Defaults to 10. n_jobs (int, optional): Number of parallel jobs to run. Defaults to -1. print_paths (bool, optional): Whether to print the paths or not. Defaults to False. Returns: List[PathObject]: list of length n_random_samples, contining the randomly create PathObjects \"\"\" # Check input is valid self . _assert_valid_simulation_input ( sample_covariates , origin_state , current_time , n_random_samples , max_transitions , n_jobs , print_paths , ) if n_jobs is None : # no parallelization runs = [] for i in tqdm ( range ( 0 , n_random_samples )): runs . append ( self . _one_monte_carlo_run ( sample_covariates , origin_state , max_transitions , current_time ) ) else : # Run parallel jobs runs = Parallel ( n_jobs = n_jobs )( delayed ( self . _one_monte_carlo_run )( sample_covariates , origin_state , max_transitions , current_time ) for i in tqdm ( range ( 0 , n_random_samples )) ) if print_paths : self . _print_paths ( runs ) return runs","title":"run_monte_carlo_simulation()"},{"location":"api/multistate_simulator/","text":"This class configures a multi-state model simulator from predefined model parts. It inherits from the MultiStateModel class, but instead of being fitted to data, it is configured based on predefined models. Parameters: Name Type Description Default competing_risks_models_list List[Dict] A list of dictionaries, each of which contains the following keys: origin_state: The state from which the simulation starts. target_states: A list of states to which the simulation transitions. model_defs: A dictionary containing the following keys: coefs: A list of coefficients for the competing risks model. baseline_hazard: A list of baseline hazards for the competing risks model. required terminal_states List[int] A list of states that are terminal states. required update_covariates_fn Callable[ [Series, int, int, float, float], Series ] A function that takes in a covariate dataframe and returns a covariate dataframe.. Defaults to default_update_covariates_function. <function default_update_covariates_function at 0x7fb325cdaca0> covariate_names List[str] A list of covariate names.. Defaults to None. None states_labels Dict[int, str] A dictionary of short state labels. Defaults to None. required Note The update_covariates_fn could be any function you choose to write, but it needs to have the following parameter types (in this order): pandas Series, int, int, float, float, and return a pandas Series. Source code in pymsm/simulation.py class MultiStateSimulator ( MultiStateModel ): \"\"\"This class configures a multi-state model simulator from predefined model parts. It inherits from the MultiStateModel class, but instead of being fitted to data, it is configured based on predefined models. Args: competing_risks_models_list (List[Dict]): A list of dictionaries, each of which contains the following keys: origin_state: The state from which the simulation starts. target_states: A list of states to which the simulation transitions. model_defs: A dictionary containing the following keys: coefs: A list of coefficients for the competing risks model. baseline_hazard: A list of baseline hazards for the competing risks model. terminal_states (List[int]): A list of states that are terminal states. update_covariates_fn (Callable[ [Series, int, int, float, float], Series ], optional): A function that takes in a covariate dataframe and returns a covariate dataframe.. Defaults to default_update_covariates_function. covariate_names (List[str], optional): A list of covariate names.. Defaults to None. states_labels (Dict[int, str], optional): A dictionary of short state labels. Defaults to None. Note: The update_covariates_fn could be any function you choose to write, but it needs to have the following parameter types (in this order): pandas Series, int, int, float, float, and return a pandas Series. \"\"\" def __init__ ( self , competing_risks_models_list : List [ Dict ], terminal_states : List [ int ], update_covariates_fn : Callable [ [ Series , int , int , float , float ], Series ] = default_update_covariates_function , covariate_names : List [ str ] = None , state_labels : Dict [ int , str ] = None , ): # Configure the MSM, dataset is not relevant super () . __init__ ( dataset = None , terminal_states = terminal_states , update_covariates_fn = update_covariates_fn , covariate_names = covariate_names , event_specific_fitter = ManualCoxWrapper , competing_risk_data_format = True , state_labels = state_labels , ) # Iterate and configure each competing risks model for competing_risks_model_dict in competing_risks_models_list : self . _configure_competing_risks_model ( competing_risks_model_dict ) def _configure_competing_risks_model ( self , competing_risks_model_dict ): \"\"\"Helper function to configure a competing risks model from a dictionary containing the following keys: origin_state: The state from which the simulation starts. target_states: A list of states to which the simulation transitions. model_defs: A dictionary containing the following keys: coefs: A list of coefficients for the competing risks model. baseline_hazard: A list of baseline hazards for the competing risks model. \"\"\" origin_state = competing_risks_model_dict [ \"origin_state\" ] # Init CompetingRisksModel crm = CompetingRisksModel ( event_specific_fitter = ManualCoxWrapper ) crm . event_specific_models = {} crm . failure_types = [] self . state_specific_models [ origin_state ] = crm # Iterate and configure an EventSpecificModel for each origin_state for i , failure_type in enumerate ( competing_risks_model_dict [ \"target_states\" ]): coefs , baseline_hazard = ( competing_risks_model_dict [ \"model_defs\" ][ i ][ \"coefs\" ], competing_risks_model_dict [ \"model_defs\" ][ i ][ \"baseline_hazard\" ], ) self . state_specific_models [ origin_state ] . event_specific_models [ failure_type ] = EventSpecificModel ( failure_type = failure_type , model = ManualCoxWrapper ( coefs , baseline_hazard ), ) self . state_specific_models [ origin_state ] . event_specific_models [ failure_type ] . extract_necessary_attributes () self . state_specific_models [ origin_state ] . failure_types . append ( failure_type )","title":"Multistate simulator"},{"location":"api/pathobject/","text":"This class holds all necessary attributes of a single path for the multi state model. Parameters: Name Type Description Default covariates Series Named pandas Series of sample covariates at the initial state. Defaults to None. None states List[int] States visited (encoded as positive integers, 0 is saved for censoring), in the order visited. Defaults to None. None time_at_each_state List[float] Time at each state. Defaults to None. None sample_id int An identification of this sample. Defaults to None. None weight float Sample weight. Defaults to None. None Note If the last state is a terminal state, then the vector of times should be shorter than the vector of states by 1. Conversely, if the last state is not a terminal state, then the length of vector times should be the same as that of the states. Source code in pymsm/multi_state_competing_risks_model.py class PathObject : \"\"\"This class holds all necessary attributes of a single path for the multi state model. Args: covariates (Series, optional): Named pandas Series of sample covariates at the initial state. Defaults to None. states (List[int], optional): States visited (encoded as positive integers, 0 is saved for censoring), in the order visited. Defaults to None. time_at_each_state (List[float], optional): Time at each state. Defaults to None. sample_id (int, optional): An identification of this sample. Defaults to None. weight (float, optional): Sample weight. Defaults to None. Note: If the last state is a terminal state, then the vector of times should be shorter than the vector of states by 1. Conversely, if the last state is not a terminal state, then the length of vector times should be the same as that of the states. \"\"\" def __init__ ( self , covariates : Series = None , states : List [ int ] = None , time_at_each_state : List [ float ] = None , sample_id : int = None , weight : float = None , ): self . covariates = covariates self . states = list () if states is None else states self . time_at_each_state = ( list () if time_at_each_state is None else time_at_each_state ) self . sample_id = sample_id self . sample_weight = weight # This variable is used when simulating paths using monte carlo self . stopped_early = None def print_path ( self ): \"\"\"Helper function for printing the paths of a Monte Carlo simulation\"\"\" if self . sample_id is not None : print ( f \"Sample id: { self . sample_id } \" ) print ( f \"States: { self . states } \" ) print ( f \"Transition times: { self . time_at_each_state } \" ) if self . covariates is not None : print ( f \"Covariates: \\n { self . covariates } \" ) print_path ( self ) \u00a4 Helper function for printing the paths of a Monte Carlo simulation Source code in pymsm/multi_state_competing_risks_model.py def print_path ( self ): \"\"\"Helper function for printing the paths of a Monte Carlo simulation\"\"\" if self . sample_id is not None : print ( f \"Sample id: { self . sample_id } \" ) print ( f \"States: { self . states } \" ) print ( f \"Transition times: { self . time_at_each_state } \" ) if self . covariates is not None : print ( f \"Covariates: \\n { self . covariates } \" )","title":"Pathobject"},{"location":"api/pathobject/#pymsm.multi_state_competing_risks_model.PathObject.print_path","text":"Helper function for printing the paths of a Monte Carlo simulation Source code in pymsm/multi_state_competing_risks_model.py def print_path ( self ): \"\"\"Helper function for printing the paths of a Monte Carlo simulation\"\"\" if self . sample_id is not None : print ( f \"Sample id: { self . sample_id } \" ) print ( f \"States: { self . states } \" ) print ( f \"Transition times: { self . time_at_each_state } \" ) if self . covariates is not None : print ( f \"Covariates: \\n { self . covariates } \" )","title":"print_path()"},{"location":"full_examples/AIDSI_example/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import numpy as np import pandas as pd import matplotlib.pyplot as plt from pymsm.datasets import load_aidssi , prep_aidssi , plot_aidssi from pymsm.plotting import competingrisks_stackplot % load_ext autoreload % autoreload 2 The autoreload extension is already loaded. To reload it, use: %reload_ext autoreload From Data Analysis with Competing Risks and Intermediate States, Book by Ronald B. Geskus: The data contains information on two event types, \u201cAIDS\u201d and \u201cSI\u201d, which compete to be the first to occur. Time is given in years since HIV infection. There are two different representations of the information on the event type that occurred first. In the cause column, the event type is described in words, whereas in the status column a numeric respresentation is used. The ccr5 column contains the information on the presence of the deletion CCR5-\u220632. Individuals that don\u2019t have the deletion have the value WW (W stands for \u201cwild type\u201d). Individuals that have the deletion on one of the chromosomes have the value WM (M stands for \u201cmutation\u201d) See also: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/aidssi data = load_aidssi () data . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } patnr time status cause ccr5 1 1 9.106 1 AIDS WW 2 2 11.039 0 event-free WM 3 3 2.234 1 AIDS WW 4 4 9.878 2 SI WM 5 5 3.819 1 AIDS WW competing_risk_dataset , covariate_cols , state_labels = prep_aidssi ( data ) competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id time_entry_to_origin origin_state target_state time_transition_to_target ccr5_WW 0 1 0 1 2 9.106 1 1 2 0 1 0 11.039 0 2 3 0 1 2 2.234 1 3 4 0 1 3 9.878 0 4 5 0 1 2 3.819 1 plot_aidssi ( competing_risk_dataset , state_labels ) competingrisks_stackplot ( data = competing_risk_dataset , duration_col = 'time_transition_to_target' , event_col = 'target_state' , order_top = [ 2 ], order_bottom = [ 3 ], state_labels = state_labels );","title":"AIDSI example"},{"location":"full_examples/COVID_hospitalization_example/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); In this notebook \u00a4 This notebook provides an example of using the pymsm package in a more complex setting which includes recurring events and time-varying covariates. We will also see how to load a saved model and run simualtions. For all this, we will use Israel COVID-19 hospitalization public data , as described in Roimi et. al. 2021 . # Imports import pandas as pd import numpy as np import matplotlib.pyplot as plt from pymsm.datasets import prep_covid_hosp_data from pymsm.multi_state_competing_risks_model import MultiStateModel from pymsm.statistics import ( prob_visited_states , stats_total_time_at_states , get_path_frequencies , path_total_time_at_states ) from pymsm.simulation import MultiStateSimulator % load_ext autoreload % autoreload 2 Load data \u00a4 from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:42<00:00, 62.45it/s] # Some definitions covariate_cols = [ \"is_male\" , \"age\" , \"was_severe\" ] terminal_states = [ 4 ] state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } print ( state_labels ) {1: 'Discharged or Recovered', 2: 'Mild or Moderate', 3: 'Severe', 4: 'Deceased'} Let's look at one patients path dataset [ 567 ] . print_path () Sample id: 577 States: [2 3 4] Transition times: [ 6 31] Covariates: is_male 1.0 age 72.5 was_severe 0.0 Name: 567, dtype: float64 For the example above, we see a man aged 72.5, who follows a path of \"Mild or Moderate\"->\"Severe\"->\"Deceased\" with transition times of 6 and 31 days. Path frequencies \u00a4 We can print out a summary for all different trajectories in the data path_freqs = get_path_frequencies ( dataset , state_labels_short ) print ( path_freqs ) M->R 1906 M 202 M->S 76 S->D 74 M->S->D 59 M->S->M->R 46 M->D 44 M->R->M->R 42 S 42 M->R->M 36 M->S->M 35 S->M->R 28 S->M 27 M->S->M->S 8 S->R 6 S->M->S 5 S->M->S->M->R 3 S->M->D 3 M->S->M->S->M 3 M->S->M->S->M->R 3 M->R->M->R->M->R 3 M->S->R 3 S->M->S->D 2 M->S->M->D 2 M->R->M->S 2 S->M->S->M->S->M 2 M->R->M->D 2 M->R->M->R->M 2 M->R->S 1 M->R->M->R->M->R->M->R->M->R->C 1 M->S->M->R->M->R 1 M->R->S->M->R 1 S->M->S->M->S->M->R 1 S->M->S->M->D 1 S->M->R->M 1 M->S->M->S->M->S->M 1 M->S->M->S->M->S 1 dtype: int64 Define time-varying covariates \u00a4 We can define a custom \"update_covariates_function\" such as below: def covid_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None , ): covariates = covariates_entering_origin_state . copy () # update is_severe covariate if origin_state == 3 : covariates [ 'was_severe' ] = 1 # # update cum_hosp_tim covariate # if ((origin_state==2) & (origin_state==3)): # covariates[\"cum_hosp_time\"] += time_at_origin return covariates Fitting the Multistate model \u00a4 multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , ) multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 >>> Fitting Transition to State: 3, n events: 2 /opt/conda/lib/python3.9/site-packages/lifelines/utils/__init__.py:1123: ConvergenceWarning: Column is_male have very low variance when conditioned on death event present or not. This may harm convergence. This could be a form of 'complete separation'. For example, try the following code: >>> events = df['target_state'].astype(bool) >>> print(df.loc[events, 'is_male'].var()) >>> print(df.loc[~events, 'is_male'].var()) A very low variance means that the column is_male completely determines whether a subject dies or not. See https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression. warnings.warn(dedent(warning_text), ConvergenceWarning) /opt/conda/lib/python3.9/site-packages/lifelines/fitters/coxph_fitter.py:1594: ConvergenceWarning: Newton-Rhaphson convergence completed successfully but norm(delta) is still high, 0.537. This may imply non-unique solutions to the maximum likelihood. Perhaps there is collinearity or complete separation in the dataset? warnings.warn( Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 1, n events: 9 /opt/conda/lib/python3.9/site-packages/lifelines/utils/__init__.py:1123: ConvergenceWarning: Column was_severe have very low variance when conditioned on death event present or not. This may harm convergence. This could be a form of 'complete separation'. For example, try the following code: >>> events = df['target_state'].astype(bool) >>> print(df.loc[events, 'was_severe'].var()) >>> print(df.loc[~events, 'was_severe'].var()) A very low variance means that the column was_severe completely determines whether a subject dies or not. See https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression. warnings.warn(dedent(warning_text), ConvergenceWarning) /opt/conda/lib/python3.9/site-packages/lifelines/fitters/coxph_fitter.py:1594: ConvergenceWarning: Newton-Rhaphson convergence completed successfully but norm(delta) is still high, 0.262. This may imply non-unique solutions to the maximum likelihood. Perhaps there is collinearity or complete separation in the dataset? warnings.warn( >>> Fitting Transition to State: 4, n events: 135 multi_state_model . transition_table .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135 Note that we get some warnings for some of the transitions. These should be handled or at least acknowledged when fitting a model. Another option might be to discard these transitions that contain a small number of samples. We can set the trim_transitions_threshold to a minimal nuber of samples for which a model will be trained. Let's set this to 10 below Trimming transitions \u00a4 multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , trim_transitions_threshold = 10 ) multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 4, n events: 135 multi_state_model . transition_table () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 0 0 Mild or Moderate 309 2135 0 275 52 Severe 135 0 193 0 135 Single patient stats \u00a4 Let's take a look at how the model models transitions for a single patient - a female aged 75 We'll run a Monte-Carlo simulation for 100 samples and present some path statistics # Run MC for a sample single patient mc_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 2 , current_time = 0 , n_random_samples = 100 , max_transitions = 10 , print_paths = False , n_jobs =- 1 ) 32%|\u2588\u2588\u2588\u258f | 32/100 [00:16<00:43, 1.56it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 56%|\u2588\u2588\u2588\u2588\u2588\u258c | 56/100 [00:33<00:29, 1.48it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 80/100 [00:49<00:13, 1.43it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [01:01<00:00, 1.61it/s] /home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() Let's calculate the probability of being in any of the states and also obtain stats regarding time in each state # Probability of visiting any of the states for state , state_label in state_labels . items (): if state == 0 : continue print ( f \"Probabilty of ever being { state_label } = { prob_visited_states ( mc_paths , states = [ state ]) } \" ) # Stats for times at states dfs = [] for state , state_label in state_labels . items (): if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths , states = [ state ]), index = [ state_label ], ) ) pd . concat ( dfs ) . round ( 3 ) . T Probabilty of ever being Discharged\\Recovered = 0.09 Probabilty of ever being Mild or Moderate = 1.0 Probabilty of ever being Severe = 0.24 Probabilty of ever being Deceased = 1.0 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Discharged\\Recovered Mild or Moderate Severe time_in_state_mean 3.970 4.070 0.470 time_in_state_std 14.983 2.507 1.253 time_in_state_median 0.000 4.000 0.000 time_in_state_min 0.000 1.000 0.000 time_in_state_max 96.000 18.000 7.000 time_in_state_quantile_0.1 0.000 2.000 0.000 time_in_state_quantile_0.25 0.000 3.000 0.000 time_in_state_quantile_0.75 0.000 5.000 0.000 time_in_state_quantile_0.9 0.000 7.000 2.000 Print out the path frequencies for the sampled paths path_freqs = get_path_frequencies ( mc_paths , state_labels ) path_freqs . head ( 10 ) Mild or Moderate->Deceased 67 Mild or Moderate->Severe->Deceased 24 Mild or Moderate->Discharged\\\\Recovered->Mild or Moderate->Deceased 9 dtype: int64 A CDF for the total time in hospital los = np . array ([ path_total_time_at_states ( path , states = [ 2 , 3 ]) for path in mc_paths ]) fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 5 )) ax . plot ( np . sort ( los ), np . linspace ( 0 , 1 , len ( los ), endpoint = False ), lw = 5 ) # ax.set_xlim(0,20) ax . set_ylabel ( 'CDF of Length of Stay' ) ax . set_xlabel ( 'Days' ); We can also look at Monte-Carlo simulations for the same patient, assuming we already know she has been in the Severe (3) state, for 2 days. To do this, we simply need to set the origin_state to 3, set the current_time to 2, and update her covariates accordingly. # Run MC for a sample single patient mc_paths_severe = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 1 }), origin_state = 3 , current_time = 2 , n_random_samples = 100 , max_transitions = 10 , print_paths = False , n_jobs =- 1 ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:59<00:00, 1.67it/s] /home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() Now we can calculate the probability of being in any of the states and obtain statistics regarding time in each state. We can compare these to the statistics we obtained above, when the patient started in a Mild (2) state. # Probability of visiting any of the states for state , state_label in state_labels . items (): if state == 0 : continue print ( f \"Probabilty of ever being { state_label } = { prob_visited_states ( mc_paths_severe , states = [ state ]) } \" ) # Stats for times at states dfs = [] for state , state_label in state_labels . items (): if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths_severe , states = [ state ]), index = [ state_label ], ) ) pd . concat ( dfs ) . round ( 3 ) . T Probabilty of ever being Discharged\\Recovered = 0.0 Probabilty of ever being Mild or Moderate = 0.11 Probabilty of ever being Severe = 1.0 Probabilty of ever being Deceased = 1.0 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Discharged\\Recovered Mild or Moderate Severe time_in_state_mean 0.0 0.100 8.570 time_in_state_std 0.0 0.458 10.872 time_in_state_median 0.0 0.000 5.000 time_in_state_min 0.0 0.000 0.000 time_in_state_max 0.0 3.000 83.000 time_in_state_quantile_0.1 0.0 0.000 0.000 time_in_state_quantile_0.25 0.0 0.000 2.750 time_in_state_quantile_0.75 0.0 0.000 10.000 time_in_state_quantile_0.9 0.0 0.000 19.000 Saving the model and configuring a simulator \u00a4 We can save the model for later use, and configure a simulator to generate simulated paths from pymsm.simulation import extract_competing_risks_models_list_from_msm competing_risks_models_list = extract_competing_risks_models_list_from_msm ( multi_state_model , verbose = True ) # Configure the simulator mssim = MultiStateSimulator ( competing_risks_models_list , terminal_states = [ 5 , 6 ], update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , ) 2 1 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f279807b3d0> 2 3 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f2798071280> 2 4 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f279807bf10> 1 2 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f2799dd9dc0> 3 2 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f27d41c56d0> 3 4 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f27d7a33fa0> And now we can sample paths from this simulator # Run MC for a sample single patient sim_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 3 , current_time = 2 , n_random_samples = 5 , max_transitions = 10 , print_paths = True , n_jobs =- 1 ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [00:00<00:00, 1717.99it/s] States: [3, 4] Transition times: [7.455064368055986e-06] States: [3, 4] Transition times: [5.683086033370088e-05] States: [3, 4] Transition times: [1.0000540635121609] States: [3, 4] Transition times: [5.76903884628166e-05] States: [3, 4] Transition times: [3.2004960103027e-05]","title":"COVID hospitalization example"},{"location":"full_examples/COVID_hospitalization_example/#in-this-notebook","text":"This notebook provides an example of using the pymsm package in a more complex setting which includes recurring events and time-varying covariates. We will also see how to load a saved model and run simualtions. For all this, we will use Israel COVID-19 hospitalization public data , as described in Roimi et. al. 2021 . # Imports import pandas as pd import numpy as np import matplotlib.pyplot as plt from pymsm.datasets import prep_covid_hosp_data from pymsm.multi_state_competing_risks_model import MultiStateModel from pymsm.statistics import ( prob_visited_states , stats_total_time_at_states , get_path_frequencies , path_total_time_at_states ) from pymsm.simulation import MultiStateSimulator % load_ext autoreload % autoreload 2","title":"In this notebook"},{"location":"full_examples/COVID_hospitalization_example/#load-data","text":"from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:42<00:00, 62.45it/s] # Some definitions covariate_cols = [ \"is_male\" , \"age\" , \"was_severe\" ] terminal_states = [ 4 ] state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } print ( state_labels ) {1: 'Discharged or Recovered', 2: 'Mild or Moderate', 3: 'Severe', 4: 'Deceased'} Let's look at one patients path dataset [ 567 ] . print_path () Sample id: 577 States: [2 3 4] Transition times: [ 6 31] Covariates: is_male 1.0 age 72.5 was_severe 0.0 Name: 567, dtype: float64 For the example above, we see a man aged 72.5, who follows a path of \"Mild or Moderate\"->\"Severe\"->\"Deceased\" with transition times of 6 and 31 days.","title":"Load data"},{"location":"full_examples/COVID_hospitalization_example/#path-frequencies","text":"We can print out a summary for all different trajectories in the data path_freqs = get_path_frequencies ( dataset , state_labels_short ) print ( path_freqs ) M->R 1906 M 202 M->S 76 S->D 74 M->S->D 59 M->S->M->R 46 M->D 44 M->R->M->R 42 S 42 M->R->M 36 M->S->M 35 S->M->R 28 S->M 27 M->S->M->S 8 S->R 6 S->M->S 5 S->M->S->M->R 3 S->M->D 3 M->S->M->S->M 3 M->S->M->S->M->R 3 M->R->M->R->M->R 3 M->S->R 3 S->M->S->D 2 M->S->M->D 2 M->R->M->S 2 S->M->S->M->S->M 2 M->R->M->D 2 M->R->M->R->M 2 M->R->S 1 M->R->M->R->M->R->M->R->M->R->C 1 M->S->M->R->M->R 1 M->R->S->M->R 1 S->M->S->M->S->M->R 1 S->M->S->M->D 1 S->M->R->M 1 M->S->M->S->M->S->M 1 M->S->M->S->M->S 1 dtype: int64","title":"Path frequencies"},{"location":"full_examples/COVID_hospitalization_example/#define-time-varying-covariates","text":"We can define a custom \"update_covariates_function\" such as below: def covid_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None , ): covariates = covariates_entering_origin_state . copy () # update is_severe covariate if origin_state == 3 : covariates [ 'was_severe' ] = 1 # # update cum_hosp_tim covariate # if ((origin_state==2) & (origin_state==3)): # covariates[\"cum_hosp_time\"] += time_at_origin return covariates","title":"Define time-varying covariates"},{"location":"full_examples/COVID_hospitalization_example/#fitting-the-multistate-model","text":"multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , ) multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 >>> Fitting Transition to State: 3, n events: 2 /opt/conda/lib/python3.9/site-packages/lifelines/utils/__init__.py:1123: ConvergenceWarning: Column is_male have very low variance when conditioned on death event present or not. This may harm convergence. This could be a form of 'complete separation'. For example, try the following code: >>> events = df['target_state'].astype(bool) >>> print(df.loc[events, 'is_male'].var()) >>> print(df.loc[~events, 'is_male'].var()) A very low variance means that the column is_male completely determines whether a subject dies or not. See https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression. warnings.warn(dedent(warning_text), ConvergenceWarning) /opt/conda/lib/python3.9/site-packages/lifelines/fitters/coxph_fitter.py:1594: ConvergenceWarning: Newton-Rhaphson convergence completed successfully but norm(delta) is still high, 0.537. This may imply non-unique solutions to the maximum likelihood. Perhaps there is collinearity or complete separation in the dataset? warnings.warn( Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 1, n events: 9 /opt/conda/lib/python3.9/site-packages/lifelines/utils/__init__.py:1123: ConvergenceWarning: Column was_severe have very low variance when conditioned on death event present or not. This may harm convergence. This could be a form of 'complete separation'. For example, try the following code: >>> events = df['target_state'].astype(bool) >>> print(df.loc[events, 'was_severe'].var()) >>> print(df.loc[~events, 'was_severe'].var()) A very low variance means that the column was_severe completely determines whether a subject dies or not. See https://stats.stackexchange.com/questions/11109/how-to-deal-with-perfect-separation-in-logistic-regression. warnings.warn(dedent(warning_text), ConvergenceWarning) /opt/conda/lib/python3.9/site-packages/lifelines/fitters/coxph_fitter.py:1594: ConvergenceWarning: Newton-Rhaphson convergence completed successfully but norm(delta) is still high, 0.262. This may imply non-unique solutions to the maximum likelihood. Perhaps there is collinearity or complete separation in the dataset? warnings.warn( >>> Fitting Transition to State: 4, n events: 135 multi_state_model . transition_table .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135 Note that we get some warnings for some of the transitions. These should be handled or at least acknowledged when fitting a model. Another option might be to discard these transitions that contain a small number of samples. We can set the trim_transitions_threshold to a minimal nuber of samples for which a model will be trained. Let's set this to 10 below","title":"Fitting the Multistate model"},{"location":"full_examples/COVID_hospitalization_example/#trimming-transitions","text":"multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , trim_transitions_threshold = 10 ) multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 4, n events: 135 multi_state_model . transition_table () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 0 0 Mild or Moderate 309 2135 0 275 52 Severe 135 0 193 0 135","title":"Trimming transitions"},{"location":"full_examples/COVID_hospitalization_example/#single-patient-stats","text":"Let's take a look at how the model models transitions for a single patient - a female aged 75 We'll run a Monte-Carlo simulation for 100 samples and present some path statistics # Run MC for a sample single patient mc_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 2 , current_time = 0 , n_random_samples = 100 , max_transitions = 10 , print_paths = False , n_jobs =- 1 ) 32%|\u2588\u2588\u2588\u258f | 32/100 [00:16<00:43, 1.56it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 56%|\u2588\u2588\u2588\u2588\u2588\u258c | 56/100 [00:33<00:29, 1.48it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 80/100 [00:49<00:13, 1.43it/s]/home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [01:01<00:00, 1.61it/s] /home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() Let's calculate the probability of being in any of the states and also obtain stats regarding time in each state # Probability of visiting any of the states for state , state_label in state_labels . items (): if state == 0 : continue print ( f \"Probabilty of ever being { state_label } = { prob_visited_states ( mc_paths , states = [ state ]) } \" ) # Stats for times at states dfs = [] for state , state_label in state_labels . items (): if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths , states = [ state ]), index = [ state_label ], ) ) pd . concat ( dfs ) . round ( 3 ) . T Probabilty of ever being Discharged\\Recovered = 0.09 Probabilty of ever being Mild or Moderate = 1.0 Probabilty of ever being Severe = 0.24 Probabilty of ever being Deceased = 1.0 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Discharged\\Recovered Mild or Moderate Severe time_in_state_mean 3.970 4.070 0.470 time_in_state_std 14.983 2.507 1.253 time_in_state_median 0.000 4.000 0.000 time_in_state_min 0.000 1.000 0.000 time_in_state_max 96.000 18.000 7.000 time_in_state_quantile_0.1 0.000 2.000 0.000 time_in_state_quantile_0.25 0.000 3.000 0.000 time_in_state_quantile_0.75 0.000 5.000 0.000 time_in_state_quantile_0.9 0.000 7.000 2.000 Print out the path frequencies for the sampled paths path_freqs = get_path_frequencies ( mc_paths , state_labels ) path_freqs . head ( 10 ) Mild or Moderate->Deceased 67 Mild or Moderate->Severe->Deceased 24 Mild or Moderate->Discharged\\\\Recovered->Mild or Moderate->Deceased 9 dtype: int64 A CDF for the total time in hospital los = np . array ([ path_total_time_at_states ( path , states = [ 2 , 3 ]) for path in mc_paths ]) fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 5 )) ax . plot ( np . sort ( los ), np . linspace ( 0 , 1 , len ( los ), endpoint = False ), lw = 5 ) # ax.set_xlim(0,20) ax . set_ylabel ( 'CDF of Length of Stay' ) ax . set_xlabel ( 'Days' ); We can also look at Monte-Carlo simulations for the same patient, assuming we already know she has been in the Severe (3) state, for 2 days. To do this, we simply need to set the origin_state to 3, set the current_time to 2, and update her covariates accordingly. # Run MC for a sample single patient mc_paths_severe = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 1 }), origin_state = 3 , current_time = 2 , n_random_samples = 100 , max_transitions = 10 , print_paths = False , n_jobs =- 1 ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:59<00:00, 1.67it/s] /home/hagair/repo/pymsm/src/pymsm/multi_state_competing_risks_model.py:594: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() Now we can calculate the probability of being in any of the states and obtain statistics regarding time in each state. We can compare these to the statistics we obtained above, when the patient started in a Mild (2) state. # Probability of visiting any of the states for state , state_label in state_labels . items (): if state == 0 : continue print ( f \"Probabilty of ever being { state_label } = { prob_visited_states ( mc_paths_severe , states = [ state ]) } \" ) # Stats for times at states dfs = [] for state , state_label in state_labels . items (): if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths_severe , states = [ state ]), index = [ state_label ], ) ) pd . concat ( dfs ) . round ( 3 ) . T Probabilty of ever being Discharged\\Recovered = 0.0 Probabilty of ever being Mild or Moderate = 0.11 Probabilty of ever being Severe = 1.0 Probabilty of ever being Deceased = 1.0 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Discharged\\Recovered Mild or Moderate Severe time_in_state_mean 0.0 0.100 8.570 time_in_state_std 0.0 0.458 10.872 time_in_state_median 0.0 0.000 5.000 time_in_state_min 0.0 0.000 0.000 time_in_state_max 0.0 3.000 83.000 time_in_state_quantile_0.1 0.0 0.000 0.000 time_in_state_quantile_0.25 0.0 0.000 2.750 time_in_state_quantile_0.75 0.0 0.000 10.000 time_in_state_quantile_0.9 0.0 0.000 19.000","title":"Single patient stats"},{"location":"full_examples/COVID_hospitalization_example/#saving-the-model-and-configuring-a-simulator","text":"We can save the model for later use, and configure a simulator to generate simulated paths from pymsm.simulation import extract_competing_risks_models_list_from_msm competing_risks_models_list = extract_competing_risks_models_list_from_msm ( multi_state_model , verbose = True ) # Configure the simulator mssim = MultiStateSimulator ( competing_risks_models_list , terminal_states = [ 5 , 6 ], update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels , ) 2 1 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f279807b3d0> 2 3 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f2798071280> 2 4 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f279807bf10> 1 2 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f2799dd9dc0> 3 2 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f27d41c56d0> 3 4 <pymsm.competing_risks_model.EventSpecificModel object at 0x7f27d7a33fa0> And now we can sample paths from this simulator # Run MC for a sample single patient sim_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 3 , current_time = 2 , n_random_samples = 5 , max_transitions = 10 , print_paths = True , n_jobs =- 1 ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [00:00<00:00, 1717.99it/s] States: [3, 4] Transition times: [7.455064368055986e-06] States: [3, 4] Transition times: [5.683086033370088e-05] States: [3, 4] Transition times: [1.0000540635121609] States: [3, 4] Transition times: [5.76903884628166e-05] States: [3, 4] Transition times: [3.2004960103027e-05]","title":"Saving the model and configuring a simulator"},{"location":"full_examples/EBMT_example/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); The EBMT dataset \u00a4 import pandas as pd from pymsm.multi_state_competing_risks_model import MultiStateModel Data from the European Society for Blood and Marrow Transplantation (EBMT) A data frame of 2279 patients transplanted at the EBMT between 1985 and 1998. (from R mstate package, see: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/EBMT%20data) from pymsm.datasets import load_ebmt , prep_ebmt_long , plot_ebmt load_ebmt () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id from to trans Tstart Tstop time status match proph year agecl 1 1 1 2 1 0.0 22.0 22.0 1 no gender mismatch no 1995-1998 20-40 2 1 1 3 2 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 3 1 1 5 3 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 4 1 1 6 4 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 5 1 2 4 5 22.0 995.0 973.0 0 no gender mismatch no 1995-1998 20-40 competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 plot_ebmt ( competing_risk_dataset , state_labels , covariate_cols , terminal_states = [ 5 , 6 ]) Multi-state model based on Survival-Trees \u00a4 terminal_states = [ 5 , 6 ] multi_state_model = MultiStateModel ( dataset = competing_risk_dataset , terminal_states = terminal_states , covariate_names = covariate_cols , competing_risk_data_format = True , state_labels = state_labels ) multi_state_model . fit () Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 785 >>> Fitting Transition to State: 3, n events: 907 >>> Fitting Transition to State: 5, n events: 95 >>> Fitting Transition to State: 6, n events: 160 Fitting Model at State: 2 >>> Fitting Transition to State: 5, n events: 112 >>> Fitting Transition to State: 6, n events: 39 >>> Fitting Transition to State: 4, n events: 227 Fitting Model at State: 3 >>> Fitting Transition to State: 4, n events: 433 >>> Fitting Transition to State: 6, n events: 197 >>> Fitting Transition to State: 5, n events: 56 Fitting Model at State: 4 >>> Fitting Transition to State: 5, n events: 107 >>> Fitting Transition to State: 6, n events: 137 Single patient statistics \u00a4 # Run MC for a sample single patient mc_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = competing_risk_dataset . loc [ 0 , covariate_cols ], origin_state = 1 , current_time = 0 , n_random_samples = 1000 , max_transitions = 10 , ) 20%|\u2588\u2588 | 200/1000 [00:34<02:02, 6.53it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 664/1000 [01:41<00:48, 7.00it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 792/1000 [01:59<00:30, 6.82it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 996/1000 [02:29<00:00, 6.93it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [02:29<00:00, 6.68it/s] from pymsm.statistics import prob_visited_states , stats_total_time_at_states all_states = competing_risk_dataset [ \"target_state\" ] . unique () # Probability of visiting any of the states for state in all_states : if state == 0 : continue print ( f \"Probabilty of { state_labels [ state ] } = { prob_visited_states ( mc_paths , states = [ state ]) } \" ) # Probability of terminal states - Death and Relapse print ( f \"Probabilty of any terminal state = { prob_visited_states ( mc_paths , states = multi_state_model . terminal_states ) } \" ) Probabilty of Rec = 0.521 Probabilty of AE = 0.37 Probabilty of AE & Rec = 0.677 Probabilty of Relapse = 0.305 Probabilty of Death = 0.695 Probabilty of any terminal state = 1.0 # Stats for times at states dfs = [] for state in all_states : if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths , states = [ state ]), index = [ state_labels [ state ]], ) ) pd . concat ( dfs ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } time_in_state_mean time_in_state_std time_in_state_median time_in_state_min time_in_state_max time_in_state_quantile_0.1 time_in_state_quantile_0.25 time_in_state_quantile_0.75 time_in_state_quantile_0.9 Rec 71.842996 382.733580 0.999979 0.0 4228.999967 0.0 0.0 18.000004 56.099967 AE 76.118467 380.102104 0.000000 0.0 4702.999975 0.0 0.0 15.999921 105.999959 AE & Rec 1020.443978 1607.097318 137.999967 0.0 4761.999903 0.0 0.0 1150.499969 4205.999946","title":"EBMT example"},{"location":"full_examples/EBMT_example/#the-ebmt-dataset","text":"import pandas as pd from pymsm.multi_state_competing_risks_model import MultiStateModel Data from the European Society for Blood and Marrow Transplantation (EBMT) A data frame of 2279 patients transplanted at the EBMT between 1985 and 1998. (from R mstate package, see: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/EBMT%20data) from pymsm.datasets import load_ebmt , prep_ebmt_long , plot_ebmt load_ebmt () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id from to trans Tstart Tstop time status match proph year agecl 1 1 1 2 1 0.0 22.0 22.0 1 no gender mismatch no 1995-1998 20-40 2 1 1 3 2 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 3 1 1 5 3 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 4 1 1 6 4 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 5 1 2 4 5 22.0 995.0 973.0 0 no gender mismatch no 1995-1998 20-40 competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 plot_ebmt ( competing_risk_dataset , state_labels , covariate_cols , terminal_states = [ 5 , 6 ])","title":"The EBMT dataset"},{"location":"full_examples/EBMT_example/#multi-state-model-based-on-survival-trees","text":"terminal_states = [ 5 , 6 ] multi_state_model = MultiStateModel ( dataset = competing_risk_dataset , terminal_states = terminal_states , covariate_names = covariate_cols , competing_risk_data_format = True , state_labels = state_labels ) multi_state_model . fit () Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 785 >>> Fitting Transition to State: 3, n events: 907 >>> Fitting Transition to State: 5, n events: 95 >>> Fitting Transition to State: 6, n events: 160 Fitting Model at State: 2 >>> Fitting Transition to State: 5, n events: 112 >>> Fitting Transition to State: 6, n events: 39 >>> Fitting Transition to State: 4, n events: 227 Fitting Model at State: 3 >>> Fitting Transition to State: 4, n events: 433 >>> Fitting Transition to State: 6, n events: 197 >>> Fitting Transition to State: 5, n events: 56 Fitting Model at State: 4 >>> Fitting Transition to State: 5, n events: 107 >>> Fitting Transition to State: 6, n events: 137","title":"Multi-state model based on Survival-Trees"},{"location":"full_examples/EBMT_example/#single-patient-statistics","text":"# Run MC for a sample single patient mc_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = competing_risk_dataset . loc [ 0 , covariate_cols ], origin_state = 1 , current_time = 0 , n_random_samples = 1000 , max_transitions = 10 , ) 20%|\u2588\u2588 | 200/1000 [00:34<02:02, 6.53it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 664/1000 [01:41<00:48, 7.00it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 792/1000 [01:59<00:30, 6.82it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 996/1000 [02:29<00:00, 6.93it/s]/workspaces/pymsm/src/pymsm/multi_state_competing_risks_model.py:600: RuntimeWarning: invalid value encountered in true_divide probability_for_each_t / probability_for_each_t.max() 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [02:29<00:00, 6.68it/s] from pymsm.statistics import prob_visited_states , stats_total_time_at_states all_states = competing_risk_dataset [ \"target_state\" ] . unique () # Probability of visiting any of the states for state in all_states : if state == 0 : continue print ( f \"Probabilty of { state_labels [ state ] } = { prob_visited_states ( mc_paths , states = [ state ]) } \" ) # Probability of terminal states - Death and Relapse print ( f \"Probabilty of any terminal state = { prob_visited_states ( mc_paths , states = multi_state_model . terminal_states ) } \" ) Probabilty of Rec = 0.521 Probabilty of AE = 0.37 Probabilty of AE & Rec = 0.677 Probabilty of Relapse = 0.305 Probabilty of Death = 0.695 Probabilty of any terminal state = 1.0 # Stats for times at states dfs = [] for state in all_states : if state == 0 or state in terminal_states : continue dfs . append ( pd . DataFrame ( data = stats_total_time_at_states ( mc_paths , states = [ state ]), index = [ state_labels [ state ]], ) ) pd . concat ( dfs ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } time_in_state_mean time_in_state_std time_in_state_median time_in_state_min time_in_state_max time_in_state_quantile_0.1 time_in_state_quantile_0.25 time_in_state_quantile_0.75 time_in_state_quantile_0.9 Rec 71.842996 382.733580 0.999979 0.0 4228.999967 0.0 0.0 18.000004 56.099967 AE 76.118467 380.102104 0.000000 0.0 4702.999975 0.0 0.0 15.999921 105.999959 AE & Rec 1020.443978 1607.097318 137.999967 0.0 4761.999903 0.0 0.0 1150.499969 4205.999946","title":"Single patient statistics"},{"location":"full_examples/Rotterdam_example/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Multi-State Model - rotterdam example \u00a4 In this notebook \u00a4 This notebook provides a first example of using the pymsm package, using the rotterdam dataset. Rotterdam dataset \u00a4 The rotterdam data set includes 2982 primary breast cancers patients whose data records were included in the Rotterdam tumor bank. Patients were followed for a time ranging between 1 to 231 months (median 107 months), and outcomes were defined as disease recurrence or death from any cause. This data includes 2982 patients, with 15 covariates, and was extracted from R survival package. For more information see page 113 in https://cran.r-project.org/web/packages/survival/survival.pdf. Let\u2019s load the dataset, which holds the transitions for each patient between the three states as decribed in the graph below from pymsm.datasets import prep_rotterdam , plot_rotterdam dataset , state_labels = prep_rotterdam () plot_rotterdam ( dataset , state_labels ) print ( 'dataset type: {} ' . format ( type ( dataset ))) print ( 'elements type: {} ' . format ( type ( dataset [ 0 ]))) dataset type: <class 'list'> elements type: <class 'pymsm.multi_state_competing_risks_model.PathObject'> The dataset is a list of elements from class PathObject. Each PathObject in the list corresponds to a single sample\u2019s (i.e \u201cpatient\u2019s\u201d) observed path. Let\u2019s look at one such object in detail: sample_path = dataset [ 1314 ] sample_path . print_path () Sample id: 1326 States: [1, 2, 3] Transition times: [873.999987, 1672.0000989999999] Covariates: year 1990 age 44 meno 0 grade 3 nodes 17 pgr 40 er 7 hormon 0 chemo 1 Name: 1314, dtype: object We see the following attributes: sample_id : (optional) a unique identifier of the patient. states : These are the observed states the sample visited, encoded as positive integers. Here we can see the patient moved from state 1 to 2, ending with the only terminal state (state 3). time_at_each_state : These are the observed times spent at each state. covariates : These are the patient\u2019s covariates \u201cyear\u201d \"age\" \"meno\" \"grade\" \"nodes\" \"pge\" \"er\" \"hormone\" \"chemo\" Note: if the last state is a terminal state, then the vector of times should be shorter than the vector of states by 1. Conversely, if the last state is not a terminal state, then the length of the vector of times should be the same as that of the states. In such a case, the sample is inferred to be right censored. Updating Covariates Over Time \u00a4 In order to update the patient covariates over time, we need to define a state-transition function. In this simple case, the covariates do not change and the function is trivial def default_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None ): return covariates_entering_origin_state You can define any function, as long as it recieves the following parameter types (in this order): 1. pandas Series (sample covariates when entering the origin state) 2. int (origin state number) 3. int (target state number) 4. float (time spent at origin state) 5. float (absolute time of entry to target state) If some of the parameters are not used in the function, use a default value of None, as in the example above. Defining terminal states \u00a4 terminal_states = [ 3 ] Fitting the model \u00a4 Import and init the model from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = default_update_covariates_function , state_labels = state_labels ) Fit the model multi_state_model . fit () Fitting Model at State: 1 >>> Fitting Transition to State: 3, n events: 195 >>> Fitting Transition to State: 2, n events: 1518 Fitting Model at State: 2 >>> Fitting Transition to State: 3, n events: 1077 Making predictions \u00a4 Predictions are done via monte carlo simulation. Initial patient covariates, along with the patient\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the patient arrives at a terminal state or the number of transitions exceeds the specified maximum. import numpy as np all_mcs = multi_state_model . run_monte_carlo_simulation ( # the current covariates of the patient. # especially important to use updated covariates in case of # time varying covariates along with a prediction from a point in time # during hospitalization sample_covariates = dataset [ 0 ] . covariates . values , # in this setting samples start at state 1, but # in general this can be any non-terminal state which # then serves as the simulation starting point origin_state = 1 , # in this setting we start predictions from time 0, but # predictions can be made from any point in time during the # patient's trajectory current_time = 0 , # If there is an observed upper limit on the number of transitions, we recommend # setting this value to that limit in order to prevent generation of outlier paths max_transitions = 2 , # the number of paths to simulate: n_random_samples = 100 , ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [04:52<00:00, 2.92s/it] The Simulation Results Format \u00a4 Each run is described by a list of states and times spent at each state (same format as the dataset the model is fit to). Below are two samples: mc = all_mcs [ 0 ] print ( mc . states ) print ( mc . time_at_each_state ) mc = all_mcs [ 1 ] print ( mc . states ) print ( mc . time_at_each_state ) [1, 2, 3] [1833.999988521867, 3431.0001414781336] [1, 2, 3] [259.00009320703174, 5451.999791792969]","title":"Rotterdam example"},{"location":"full_examples/Rotterdam_example/#multi-state-model-rotterdam-example","text":"","title":"Multi-State Model - rotterdam example"},{"location":"full_examples/Rotterdam_example/#in-this-notebook","text":"This notebook provides a first example of using the pymsm package, using the rotterdam dataset.","title":"In this notebook"},{"location":"full_examples/Rotterdam_example/#rotterdam-dataset","text":"The rotterdam data set includes 2982 primary breast cancers patients whose data records were included in the Rotterdam tumor bank. Patients were followed for a time ranging between 1 to 231 months (median 107 months), and outcomes were defined as disease recurrence or death from any cause. This data includes 2982 patients, with 15 covariates, and was extracted from R survival package. For more information see page 113 in https://cran.r-project.org/web/packages/survival/survival.pdf. Let\u2019s load the dataset, which holds the transitions for each patient between the three states as decribed in the graph below from pymsm.datasets import prep_rotterdam , plot_rotterdam dataset , state_labels = prep_rotterdam () plot_rotterdam ( dataset , state_labels ) print ( 'dataset type: {} ' . format ( type ( dataset ))) print ( 'elements type: {} ' . format ( type ( dataset [ 0 ]))) dataset type: <class 'list'> elements type: <class 'pymsm.multi_state_competing_risks_model.PathObject'> The dataset is a list of elements from class PathObject. Each PathObject in the list corresponds to a single sample\u2019s (i.e \u201cpatient\u2019s\u201d) observed path. Let\u2019s look at one such object in detail: sample_path = dataset [ 1314 ] sample_path . print_path () Sample id: 1326 States: [1, 2, 3] Transition times: [873.999987, 1672.0000989999999] Covariates: year 1990 age 44 meno 0 grade 3 nodes 17 pgr 40 er 7 hormon 0 chemo 1 Name: 1314, dtype: object We see the following attributes: sample_id : (optional) a unique identifier of the patient. states : These are the observed states the sample visited, encoded as positive integers. Here we can see the patient moved from state 1 to 2, ending with the only terminal state (state 3). time_at_each_state : These are the observed times spent at each state. covariates : These are the patient\u2019s covariates \u201cyear\u201d \"age\" \"meno\" \"grade\" \"nodes\" \"pge\" \"er\" \"hormone\" \"chemo\" Note: if the last state is a terminal state, then the vector of times should be shorter than the vector of states by 1. Conversely, if the last state is not a terminal state, then the length of the vector of times should be the same as that of the states. In such a case, the sample is inferred to be right censored.","title":"Rotterdam dataset"},{"location":"full_examples/Rotterdam_example/#updating-covariates-over-time","text":"In order to update the patient covariates over time, we need to define a state-transition function. In this simple case, the covariates do not change and the function is trivial def default_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None ): return covariates_entering_origin_state You can define any function, as long as it recieves the following parameter types (in this order): 1. pandas Series (sample covariates when entering the origin state) 2. int (origin state number) 3. int (target state number) 4. float (time spent at origin state) 5. float (absolute time of entry to target state) If some of the parameters are not used in the function, use a default value of None, as in the example above.","title":"Updating Covariates Over Time"},{"location":"full_examples/Rotterdam_example/#defining-terminal-states","text":"terminal_states = [ 3 ]","title":"Defining terminal states"},{"location":"full_examples/Rotterdam_example/#fitting-the-model","text":"Import and init the model from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = default_update_covariates_function , state_labels = state_labels ) Fit the model multi_state_model . fit () Fitting Model at State: 1 >>> Fitting Transition to State: 3, n events: 195 >>> Fitting Transition to State: 2, n events: 1518 Fitting Model at State: 2 >>> Fitting Transition to State: 3, n events: 1077","title":"Fitting the model"},{"location":"full_examples/Rotterdam_example/#making-predictions","text":"Predictions are done via monte carlo simulation. Initial patient covariates, along with the patient\u2019s current state are supplied. The next states are sequentially sampled via the model parameters. The process concludes when the patient arrives at a terminal state or the number of transitions exceeds the specified maximum. import numpy as np all_mcs = multi_state_model . run_monte_carlo_simulation ( # the current covariates of the patient. # especially important to use updated covariates in case of # time varying covariates along with a prediction from a point in time # during hospitalization sample_covariates = dataset [ 0 ] . covariates . values , # in this setting samples start at state 1, but # in general this can be any non-terminal state which # then serves as the simulation starting point origin_state = 1 , # in this setting we start predictions from time 0, but # predictions can be made from any point in time during the # patient's trajectory current_time = 0 , # If there is an observed upper limit on the number of transitions, we recommend # setting this value to that limit in order to prevent generation of outlier paths max_transitions = 2 , # the number of paths to simulate: n_random_samples = 100 , ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [04:52<00:00, 2.92s/it]","title":"Making predictions"},{"location":"full_examples/Rotterdam_example/#the-simulation-results-format","text":"Each run is described by a list of states and times spent at each state (same format as the dataset the model is fit to). Below are two samples: mc = all_mcs [ 0 ] print ( mc . states ) print ( mc . time_at_each_state ) mc = all_mcs [ 1 ] print ( mc . states ) print ( mc . time_at_each_state ) [1, 2, 3] [1833.999988521867, 3431.0001414781336] [1, 2, 3] [259.00009320703174, 5451.999791792969]","title":"The Simulation Results Format"},{"location":"usage/Datasets/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); PyMSM contains a few example datasets which can easily be loaded: AID-SI \u00a4 A simple 2 state competing risks dataset From Data Analysis with Competing Risks and Intermediate States , by Ronald B. Geskus: The data contains information on two event types, \u201cAIDS\u201d and \u201cSI\u201d, which compete to be the first to occur. Time is given in years since HIV infection. There are two different representations of the information on the event type that occurred first. In the cause column, the event type is described in words, whereas in the status column a numeric respresentation is used. The ccr5 column contains the information on the presence of the deletion CCR5-\u220632. Individuals that don\u2019t have the deletion have the value WW (W stands for \u201cwild type\u201d). Individuals that have the deletion on one of the chromosomes have the value WM (M stands for \u201cmutation\u201d) See also: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/aidssi from pymsm.datasets import load_aidssi , prep_aidssi , plot_aidssi data = load_aidssi () data . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } patnr time status cause ccr5 1 1 9.106 1 AIDS WW 2 2 11.039 0 event-free WM 3 3 2.234 1 AIDS WW 4 4 9.878 2 SI WM 5 5 3.819 1 AIDS WW competing_risk_dataset , covariate_cols , state_labels = prep_aidssi ( data ) competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id time_entry_to_origin origin_state target_state time_transition_to_target ccr5_WW 0 1 0 1 2 9.106 1 1 2 0 1 0 11.039 0 2 3 0 1 2 2.234 1 3 4 0 1 3 9.878 0 4 5 0 1 2 3.819 1 plot_aidssi ( competing_risk_dataset , state_labels ) Rotterdam \u00a4 A 3-state Illness-death dataset The rotterdam data set includes 2982 primary breast cancers patients whose data records were included in the Rotterdam tumor bank. Patients were followed for a time ranging between 1 to 231 months (median 107 months), and outcomes were defined as disease recurrence or death from any cause. This data includes 2982 patients, with 15 covariates, and was extracted from R survival package. For more information see page 113 in https://cran.r-project.org/web/packages/survival/survival.pdf. from pymsm.datasets import load_rotterdam , prep_rotterdam , plot_rotterdam rotterdam = load_rotterdam () rotterdam . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pid year age meno size grade nodes pgr er hormon chemo rtime recur dtime death 0 1 1992 74 1 <=20 3 0 35 291 0 0 1798.999948 0 1798.999948 0 1 2 1984 79 1 20-50 3 0 36 611 0 0 2828.000021 0 2828.000021 0 2 3 1983 44 0 <=20 2 0 138 0 0 0 6011.999804 0 6011.999804 0 3 4 1985 70 1 20-50 3 0 0 12 0 0 2623.999895 0 2623.999895 0 4 5 1983 75 1 <=20 3 0 260 409 0 0 4914.999997 0 4914.999997 0 dataset , state_labels = prep_rotterdam () plot_rotterdam ( dataset , state_labels ) EBMT \u00a4 A Multi-state dataset Data from the European Society for Blood and Marrow Transplantation (EBMT) A data frame of 2279 patients transplanted at the EBMT between 1985 and 1998. (from R mstate package, for more information see: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/EBMT%20data) from pymsm.datasets import load_ebmt , prep_ebmt_long , plot_ebmt load_ebmt () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id from to trans Tstart Tstop time status match proph year agecl 1 1 1 2 1 0.0 22.0 22.0 1 no gender mismatch no 1995-1998 20-40 2 1 1 3 2 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 3 1 1 5 3 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 4 1 1 6 4 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 5 1 2 4 5 22.0 995.0 973.0 0 no gender mismatch no 1995-1998 20-40 competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 plot_ebmt ( competing_risk_dataset , state_labels , covariate_cols , terminal_states = [ 5 , 6 ]) Covid hospitalizations in Israel \u00a4 Complex multis-state, recurring events and time-varying covariates dataset Israel COVID-19 hospitalization public data , as described in Roimi et. al. 2021 . from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:06<00:00, 426.53it/s]","title":"Datasets"},{"location":"usage/Datasets/#aid-si","text":"A simple 2 state competing risks dataset From Data Analysis with Competing Risks and Intermediate States , by Ronald B. Geskus: The data contains information on two event types, \u201cAIDS\u201d and \u201cSI\u201d, which compete to be the first to occur. Time is given in years since HIV infection. There are two different representations of the information on the event type that occurred first. In the cause column, the event type is described in words, whereas in the status column a numeric respresentation is used. The ccr5 column contains the information on the presence of the deletion CCR5-\u220632. Individuals that don\u2019t have the deletion have the value WW (W stands for \u201cwild type\u201d). Individuals that have the deletion on one of the chromosomes have the value WM (M stands for \u201cmutation\u201d) See also: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/aidssi from pymsm.datasets import load_aidssi , prep_aidssi , plot_aidssi data = load_aidssi () data . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } patnr time status cause ccr5 1 1 9.106 1 AIDS WW 2 2 11.039 0 event-free WM 3 3 2.234 1 AIDS WW 4 4 9.878 2 SI WM 5 5 3.819 1 AIDS WW competing_risk_dataset , covariate_cols , state_labels = prep_aidssi ( data ) competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id time_entry_to_origin origin_state target_state time_transition_to_target ccr5_WW 0 1 0 1 2 9.106 1 1 2 0 1 0 11.039 0 2 3 0 1 2 2.234 1 3 4 0 1 3 9.878 0 4 5 0 1 2 3.819 1 plot_aidssi ( competing_risk_dataset , state_labels )","title":"AID-SI"},{"location":"usage/Datasets/#rotterdam","text":"A 3-state Illness-death dataset The rotterdam data set includes 2982 primary breast cancers patients whose data records were included in the Rotterdam tumor bank. Patients were followed for a time ranging between 1 to 231 months (median 107 months), and outcomes were defined as disease recurrence or death from any cause. This data includes 2982 patients, with 15 covariates, and was extracted from R survival package. For more information see page 113 in https://cran.r-project.org/web/packages/survival/survival.pdf. from pymsm.datasets import load_rotterdam , prep_rotterdam , plot_rotterdam rotterdam = load_rotterdam () rotterdam . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pid year age meno size grade nodes pgr er hormon chemo rtime recur dtime death 0 1 1992 74 1 <=20 3 0 35 291 0 0 1798.999948 0 1798.999948 0 1 2 1984 79 1 20-50 3 0 36 611 0 0 2828.000021 0 2828.000021 0 2 3 1983 44 0 <=20 2 0 138 0 0 0 6011.999804 0 6011.999804 0 3 4 1985 70 1 20-50 3 0 0 12 0 0 2623.999895 0 2623.999895 0 4 5 1983 75 1 <=20 3 0 260 409 0 0 4914.999997 0 4914.999997 0 dataset , state_labels = prep_rotterdam () plot_rotterdam ( dataset , state_labels )","title":"Rotterdam"},{"location":"usage/Datasets/#ebmt","text":"A Multi-state dataset Data from the European Society for Blood and Marrow Transplantation (EBMT) A data frame of 2279 patients transplanted at the EBMT between 1985 and 1998. (from R mstate package, for more information see: https://www.rdocumentation.org/packages/mstate/versions/0.3.1/topics/EBMT%20data) from pymsm.datasets import load_ebmt , prep_ebmt_long , plot_ebmt load_ebmt () . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id from to trans Tstart Tstop time status match proph year agecl 1 1 1 2 1 0.0 22.0 22.0 1 no gender mismatch no 1995-1998 20-40 2 1 1 3 2 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 3 1 1 5 3 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 4 1 1 6 4 0.0 22.0 22.0 0 no gender mismatch no 1995-1998 20-40 5 1 2 4 5 22.0 995.0 973.0 0 no gender mismatch no 1995-1998 20-40 competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 plot_ebmt ( competing_risk_dataset , state_labels , covariate_cols , terminal_states = [ 5 , 6 ])","title":"EBMT"},{"location":"usage/Datasets/#covid-hospitalizations-in-israel","text":"Complex multis-state, recurring events and time-varying covariates dataset Israel COVID-19 hospitalization public data , as described in Roimi et. al. 2021 . from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:06<00:00, 426.53it/s]","title":"Covid hospitalizations in Israel"},{"location":"usage/Preparing_a_dataset/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Preparing a dataset for multistate modeling with PyMSM \u00a4 The first step of any multistate model is to provide the sample data of paths and covariates. There are 2 types of dataset formats which can serve as an input: 1) a list of PathObject 2) a pandas data frame in the format used to fit the CompetingRiskModel class 1. A list of PathObject \u00a4 Best to see an example: # Load Rotterdam example data from pymsm.datasets import prep_rotterdam dataset , _ = prep_rotterdam () # Print types print ( 'dataset type: {} ' . format ( type ( dataset ))) print ( 'elements type: {} ' . format ( type ( dataset [ 0 ]))) dataset type: <class 'list'> elements type: <class 'pymsm.multi_state_competing_risks_model.PathObject'> The dataset is a list of elements from class PathObject. Each PathObject in the list corresponds to a single sample\u2019s (i.e \u201cpatient\u2019s\u201d) observed path. Let\u2019s look at one such object in detail: # Display paths and covariates of one sample (#1314) sample_path = dataset [ 1314 ] sample_path . print_path () Sample id: 1326 States: [1, 2, 3] Transition times: [873.999987, 1672.0000989999999] Covariates: year 1990 age 44 meno 0 grade 3 nodes 17 pgr 40 er 7 hormon 0 chemo 1 Name: 1314, dtype: object 2. A pandas dataframe \u00a4 a pandas data frame in the format used to fit the CompetingRiskModel class. Let's see one: # Load EBMT dataset from pymsm.datasets import prep_ebmt_long competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 print ( competing_risk_dataset . columns ) Index(['sample_id', 'origin_state', 'target_state', 'time_entry_to_origin', 'time_transition_to_target', 'match_no gender mismatch', 'proph_yes', 'year_1990-1994', 'year_1995-1998', 'agecl_<=20', 'agecl_>40'], dtype='object') The competing_risk_dataset has to include the following columns: 'sample_id', 'origin_state', 'target_state', 'time_entry_to_origin', 'time_transition_to_target' which are self-explanatory, as well as any other covariate columns.","title":"Preparing a dataset"},{"location":"usage/Preparing_a_dataset/#preparing-a-dataset-for-multistate-modeling-with-pymsm","text":"The first step of any multistate model is to provide the sample data of paths and covariates. There are 2 types of dataset formats which can serve as an input: 1) a list of PathObject 2) a pandas data frame in the format used to fit the CompetingRiskModel class","title":"Preparing a dataset for multistate modeling with PyMSM"},{"location":"usage/Preparing_a_dataset/#1-a-list-of-pathobject","text":"Best to see an example: # Load Rotterdam example data from pymsm.datasets import prep_rotterdam dataset , _ = prep_rotterdam () # Print types print ( 'dataset type: {} ' . format ( type ( dataset ))) print ( 'elements type: {} ' . format ( type ( dataset [ 0 ]))) dataset type: <class 'list'> elements type: <class 'pymsm.multi_state_competing_risks_model.PathObject'> The dataset is a list of elements from class PathObject. Each PathObject in the list corresponds to a single sample\u2019s (i.e \u201cpatient\u2019s\u201d) observed path. Let\u2019s look at one such object in detail: # Display paths and covariates of one sample (#1314) sample_path = dataset [ 1314 ] sample_path . print_path () Sample id: 1326 States: [1, 2, 3] Transition times: [873.999987, 1672.0000989999999] Covariates: year 1990 age 44 meno 0 grade 3 nodes 17 pgr 40 er 7 hormon 0 chemo 1 Name: 1314, dtype: object","title":"1. A list of PathObject"},{"location":"usage/Preparing_a_dataset/#2-a-pandas-dataframe","text":"a pandas data frame in the format used to fit the CompetingRiskModel class. Let's see one: # Load EBMT dataset from pymsm.datasets import prep_ebmt_long competing_risk_dataset , covariate_cols , state_labels = prep_ebmt_long () competing_risk_dataset . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sample_id origin_state target_state time_entry_to_origin time_transition_to_target match_no gender mismatch proph_yes year_1990-1994 year_1995-1998 agecl_<=20 agecl_>40 0 1 1 2 0.0 22.0 1 0 0 1 0 0 1 1 2 0 22.0 995.0 1 0 0 1 0 0 2 2 1 3 0.0 12.0 1 0 0 1 0 0 3 2 3 4 12.0 29.0 1 0 0 1 0 0 4 2 4 5 29.0 422.0 1 0 0 1 0 0 print ( competing_risk_dataset . columns ) Index(['sample_id', 'origin_state', 'target_state', 'time_entry_to_origin', 'time_transition_to_target', 'match_no gender mismatch', 'proph_yes', 'year_1990-1994', 'year_1995-1998', 'agecl_<=20', 'agecl_>40'], dtype='object') The competing_risk_dataset has to include the following columns: 'sample_id', 'origin_state', 'target_state', 'time_entry_to_origin', 'time_transition_to_target' which are self-explanatory, as well as any other covariate columns.","title":"2. A pandas dataframe"},{"location":"usage/Simulator/","text":"Simulator \u00a4 PyMSM can be used as a simulator\\sampler for saved models See COVID hospitalization example We can save a model for later use, and then configure a simulator to generate simulated paths from pymsm.simulation import MultiStateSimulator mssim = MultiStateSimulator ( competing_risks_models_list , terminal_states = [ 5 , 6 ], update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , ) And now we can sample paths from this simulator # Run MC for a sample single patient sim_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 3 , current_time = 2 , n_random_samples = 5 , max_transitions = 10 , print_paths = True , n_jobs =- 1 )","title":"Simulator"},{"location":"usage/Simulator/#simulator","text":"PyMSM can be used as a simulator\\sampler for saved models See COVID hospitalization example We can save a model for later use, and then configure a simulator to generate simulated paths from pymsm.simulation import MultiStateSimulator mssim = MultiStateSimulator ( competing_risks_models_list , terminal_states = [ 5 , 6 ], update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , ) And now we can sample paths from this simulator # Run MC for a sample single patient sim_paths = multi_state_model . run_monte_carlo_simulation ( sample_covariates = pd . Series ({ \"is_male\" : 0 , \"age\" : 75 , \"was_severe\" : 0 }), origin_state = 3 , current_time = 2 , n_random_samples = 5 , max_transitions = 10 , print_paths = True , n_jobs =- 1 )","title":"Simulator"},{"location":"usage/competing_risks_stackplot/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); We can investigate the data for a given competing risks group of states with a probability stackplot. Let's see this in action using the AIDSI dataset: # Load and prep data from pymsm.datasets import load_aidssi , prep_aidssi data = load_aidssi () competing_risk_dataset , covariate_cols , state_labels = prep_aidssi ( data ) from pymsm.plotting import competingrisks_stackplot competingrisks_stackplot ( data = competing_risk_dataset , duration_col = 'time_transition_to_target' , event_col = 'target_state' , order_top = [ 2 ], order_bottom = [ 3 ], state_labels = state_labels ); in this stackplot we can investigate the state occupancies at any given time. in white we have the \"Event-Free\" state occupancy, and as time goes by the \"AIDS\" and \"SI\" get populated. At t=14, we see that we have no \"event-free\" patients left in this dataset.","title":"Competing risks stackplot"},{"location":"usage/custom_fitters/","text":"Custom fitters \u00a4 PyMSM allows configuration of custom event-specific-fitters. See EventSpecificFitter class which is an abstract class which specifies the API which needs to be implemented. Some custom fitters are available off-the-shelf such as Survival trees [Ishwaran 2008] Survival trees \u00a4 An example of using Survival Trees as custom event-specific-fitters in a Multistate model: from pymsm.multi_state_competing_risks_model import MultiStateModel from pymsm.survival_tree_fitter import SurvivalTreeWrapper multi_state_model = MultiStateModel ( dataset , terminal_states , default_update_covariates_function , event_specific_fitter = SurvivalTreeWrapper )","title":"Custom fitters"},{"location":"usage/custom_fitters/#custom-fitters","text":"PyMSM allows configuration of custom event-specific-fitters. See EventSpecificFitter class which is an abstract class which specifies the API which needs to be implemented. Some custom fitters are available off-the-shelf such as Survival trees [Ishwaran 2008]","title":"Custom fitters"},{"location":"usage/custom_fitters/#survival-trees","text":"An example of using Survival Trees as custom event-specific-fitters in a Multistate model: from pymsm.multi_state_competing_risks_model import MultiStateModel from pymsm.survival_tree_fitter import SurvivalTreeWrapper multi_state_model = MultiStateModel ( dataset , terminal_states , default_update_covariates_function , event_specific_fitter = SurvivalTreeWrapper )","title":"Survival trees"},{"location":"usage/examining_a_model/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); There are various ways we can examine a model - both before and after we fit it: Plot the states diagram from the data. This is one of the first things a researcher might want to look at. This will allow her to understand the avialble transitions. Display a transition table containing all available transitions and censored events. Compute and display a Path frequencies table. Understanding the data path statistics is important in multistate models and may uncover interesting findings. Examine competing risks states stackplots from an origin state. Understand how different origin states paths behave over time. States diagram \u00a4 from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:05<00:00, 494.79it/s] Transition table \u00a4 from pymsm.multi_state_competing_risks_model import MultiStateModel msm = MultiStateModel ( dataset = dataset , terminal_states = [ 4 ], state_labels = state_labels , ) msm . prep_transition_table () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135 msm . transition_matrix .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state 0 1 2 3 4 origin_state 1 2044 0 98 2 0 2 309 2135 0 275 52 3 135 9 193 0 135 msm . transition_table .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135 Path frequencies \u00a4 state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } from pymsm.statistics import get_path_frequencies path_freqs = get_path_frequencies ( dataset , state_labels_short ) path_freqs . head ( 20 ) M->R 1906 M 202 M->S 76 S->D 74 M->S->D 59 M->S->M->R 46 M->D 44 M->R->M->R 42 S 42 M->R->M 36 M->S->M 35 S->M->R 28 S->M 27 M->S->M->S 8 S->R 6 S->M->S 5 S->M->S->M->R 3 S->M->D 3 M->S->M->S->M 3 M->S->M->S->M->R 3 dtype: int64 Examine competing risks from origin state \u00a4 origin_state = 3 competing_risk_dataset = msm . competing_risk_dataset competing_risk_dataset = competing_risk_dataset [ competing_risk_dataset [ 'origin_state' ] == origin_state ] from pymsm.plotting import competingrisks_stackplot competingrisks_stackplot ( data = competing_risk_dataset , duration_col = 'time_transition_to_target' , event_col = 'target_state' , order_top = [ 1 ], order_bottom = [ 4 , 2 ], state_labels = state_labels );","title":"Examining a model"},{"location":"usage/examining_a_model/#states-diagram","text":"from pymsm.datasets import prep_covid_hosp_data , plot_covid_hosp dataset , state_labels = prep_covid_hosp_data () plot_covid_hosp ( dataset , state_labels ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:05<00:00, 494.79it/s]","title":"States diagram"},{"location":"usage/examining_a_model/#transition-table","text":"from pymsm.multi_state_competing_risks_model import MultiStateModel msm = MultiStateModel ( dataset = dataset , terminal_states = [ 4 ], state_labels = state_labels , ) msm . prep_transition_table () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135 msm . transition_matrix .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state 0 1 2 3 4 origin_state 1 2044 0 98 2 0 2 309 2135 0 275 52 3 135 9 193 0 135 msm . transition_table .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } target_state Censored Discharged\\Recovered Mild or Moderate Severe Deceased origin_state Discharged\\Recovered 2044 0 98 2 0 Mild or Moderate 309 2135 0 275 52 Severe 135 9 193 0 135","title":"Transition table"},{"location":"usage/examining_a_model/#path-frequencies","text":"state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } from pymsm.statistics import get_path_frequencies path_freqs = get_path_frequencies ( dataset , state_labels_short ) path_freqs . head ( 20 ) M->R 1906 M 202 M->S 76 S->D 74 M->S->D 59 M->S->M->R 46 M->D 44 M->R->M->R 42 S 42 M->R->M 36 M->S->M 35 S->M->R 28 S->M 27 M->S->M->S 8 S->R 6 S->M->S 5 S->M->S->M->R 3 S->M->D 3 M->S->M->S->M 3 M->S->M->S->M->R 3 dtype: int64","title":"Path frequencies"},{"location":"usage/examining_a_model/#examine-competing-risks-from-origin-state","text":"origin_state = 3 competing_risk_dataset = msm . competing_risk_dataset competing_risk_dataset = competing_risk_dataset [ competing_risk_dataset [ 'origin_state' ] == origin_state ] from pymsm.plotting import competingrisks_stackplot competingrisks_stackplot ( data = competing_risk_dataset , duration_col = 'time_transition_to_target' , event_col = 'target_state' , order_top = [ 1 ], order_bottom = [ 4 , 2 ], state_labels = state_labels );","title":"Examine competing risks from origin state"},{"location":"usage/fitting_a_multistate_model/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Fitting a model \u00a4 After preparing a dataset, we have a few more configurations to do: 1) Define terminal states in the model Optional: 2) Define a custom update function for time-varying covariates (See COVID hospitaliztion example). Default is No updating 3) Define covariate columns 4) Define state labels 5) Define minimum number of data transitions needed to fit a transition 6) Define the event specific fitters. Default is CoxWrapper. See custom_fitters for more # Load data from pymsm.datasets import prep_covid_hosp_data dataset , state_labels = prep_covid_hosp_data () # 1) Define terminal states terminal_states = [ 4 ] # 2) Define a custom update function for time-varying covariates. # Default is No updating: from pymsm.multi_state_competing_risks_model import default_update_covariates_function update_covariates_fn = default_update_covariates_function # Let's define one: def covid_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None , ): covariates = covariates_entering_origin_state . copy () # update is_severe covariate if origin_state == 3 : covariates [ 'was_severe' ] = 1 return covariates # 3) Define covariate columns covariate_cols = [ \"is_male\" , \"age\" , \"was_severe\" ] # 4) Define state labels state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } # 5) Define minimum number of data transitions needed to fit a transition trim_transitions_threshold = 10 # 6) Define the event specific fitters. Default is CoxWrapper. See custom_fitters for more from pymsm.event_specific_fitter import CoxWrapper event_specific_fitter = CoxWrapper 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:40<00:00, 65.86it/s] # Init MultistateModel from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels_short , event_specific_fitter = event_specific_fitter , trim_transitions_threshold = trim_transitions_threshold , ) Once we have the model initiated properly, we can fit it by simply calling the fit() method multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 4, n events: 135","title":"Fitting a multistate model"},{"location":"usage/fitting_a_multistate_model/#fitting-a-model","text":"After preparing a dataset, we have a few more configurations to do: 1) Define terminal states in the model Optional: 2) Define a custom update function for time-varying covariates (See COVID hospitaliztion example). Default is No updating 3) Define covariate columns 4) Define state labels 5) Define minimum number of data transitions needed to fit a transition 6) Define the event specific fitters. Default is CoxWrapper. See custom_fitters for more # Load data from pymsm.datasets import prep_covid_hosp_data dataset , state_labels = prep_covid_hosp_data () # 1) Define terminal states terminal_states = [ 4 ] # 2) Define a custom update function for time-varying covariates. # Default is No updating: from pymsm.multi_state_competing_risks_model import default_update_covariates_function update_covariates_fn = default_update_covariates_function # Let's define one: def covid_update_covariates_function ( covariates_entering_origin_state , origin_state = None , target_state = None , time_at_origin = None , abs_time_entry_to_target_state = None , ): covariates = covariates_entering_origin_state . copy () # update is_severe covariate if origin_state == 3 : covariates [ 'was_severe' ] = 1 return covariates # 3) Define covariate columns covariate_cols = [ \"is_male\" , \"age\" , \"was_severe\" ] # 4) Define state labels state_labels_short = { 0 : \"C\" , 1 : \"R\" , 2 : \"M\" , 3 : \"S\" , 4 : \"D\" } # 5) Define minimum number of data transitions needed to fit a transition trim_transitions_threshold = 10 # 6) Define the event specific fitters. Default is CoxWrapper. See custom_fitters for more from pymsm.event_specific_fitter import CoxWrapper event_specific_fitter = CoxWrapper 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2675/2675 [00:40<00:00, 65.86it/s] # Init MultistateModel from pymsm.multi_state_competing_risks_model import MultiStateModel multi_state_model = MultiStateModel ( dataset = dataset , terminal_states = terminal_states , update_covariates_fn = covid_update_covariates_function , covariate_names = covariate_cols , state_labels = state_labels_short , event_specific_fitter = event_specific_fitter , trim_transitions_threshold = trim_transitions_threshold , ) Once we have the model initiated properly, we can fit it by simply calling the fit() method multi_state_model . fit () Fitting Model at State: 2 >>> Fitting Transition to State: 1, n events: 2135 >>> Fitting Transition to State: 3, n events: 275 >>> Fitting Transition to State: 4, n events: 52 Fitting Model at State: 1 >>> Fitting Transition to State: 2, n events: 98 Fitting Model at State: 3 >>> Fitting Transition to State: 2, n events: 193 >>> Fitting Transition to State: 4, n events: 135","title":"Fitting a model"},{"location":"usage/path_sampling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Once we have the fitted model (see previous section), we can use it and run Monte-Carlo simualtions to obtain path samples for a given covariate set and state of origin. # Quickly fit a multistate model for Rotterdam data from pymsm.datasets import prep_rotterdam dataset , states_labels = prep_rotterdam () #Init MultistateModel from pymsm.multi_state_competing_risks_model import MultiStateModel , default_update_covariates_function multi_state_model = MultiStateModel ( dataset , terminal_states = [ 3 ], update_covariates_fn = default_update_covariates_function ) # Fit to data multi_state_model . fit () Fitting Model at State: 1 >>> Fitting Transition to State: 3, n events: 195 >>> Fitting Transition to State: 2, n events: 1518 Fitting Model at State: 2 >>> Fitting Transition to State: 3, n events: 1077 Once the model is ready, we can run the run_monte_carlo_simulation() method which samples random paths using Monte Carlo simulations. Initial sample covariates, along with the sample\u2019s current state need to be supplied. The next states are sequentially sampled via the model parameters. The process concludes when the sample arrives at a terminal state or the number of transitions exceeds the specified maximum, and returns a list of length n_random_samples , contining the randomly create PathObjects # Run Monte-carlo simulation simulated_paths = multi_state_model . run_monte_carlo_simulation ( # Initial sample covariates, when entering the origin state sample_covariates = dataset [ 0 ] . covariates . values , # Initial state where the path begins from origin_state = 1 , # Time when starting the sample path. Defaults to 0. current_time = 0 , # Number of random paths to create. Defaults to 100. n_random_samples = 10 , # Max number of transitions to allow in the paths. Defaults to 10. max_transitions = 2 , # Number of parallel jobs to run. Defaults to -1 (all available). n_jobs = 3 , # Whether to print the paths or not. Defaults to False. print_paths = True ) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:07<00:00, 1.42it/s] States: [1, 2, 3] Transition times: [332.00005223077005, 4342.99995976923] States: [1, 2, 3] Transition times: [631.0000141, 3465.0001279] States: [1, 2, 3] Transition times: [4794.000067, 1373.99982] States: [1, 2, 3] Transition times: [905.9999772, 1476.0000568] States: [1, 2, 3] Transition times: [2382.000034, 2637.000018] States: [1, 2, 3] Transition times: [832.0000313617267, 1102.9999616382734] States: [1, 2, 3] Transition times: [1139.0000637501248, 2711.0000012498754] States: [1, 2, 3] Transition times: [2226.999889, 3038.000241] States: [1, 2, 3] Transition times: [3371.000033, 2339.9998520000004] States: [1, 2, 3] Transition times: [526.0000380373596, 5459.000045962641]","title":"Path sampling"}]}